[{"title":"测试初级","url":"/2019/12/29/测试初级/","content":"\n# 软件测试的分类\n\n## 方法\n\n1.黑盒测试\n\n2.白盒测试\n\n3.灰盒测试\n\n## 方向\n\n1.功能测试\n\n2.性能测试\n\n3.安全测试\n\n<!--more-->\n\n## 阶段\n\n1.单元测试：方法，函数，类\n\n2.集成测试：接口\n\n3.系统测试：\n\n​\t3.1 功能\n\n​\t3.2安全\n\n​\t3.3性能\n\n​\t3.4兼容性\n\n​\t3.5易用性\n\n4.验收测试\n\n\n\n## 对象\n\n1.APP测试\n\n2.WEB测试\n\n3.物联网测试\n\n4.车联网测试\n\n5.小程序测试\n\n6.嵌入式测试\n\n\n\n# 测试的流程\n\n## 1.需求分析阶段\n\n## 2.测试设计阶段\n\n### 1.测试计划\n\n### 2.测试方案\n\n### 3.测试策略\n\n### 4.测试用例\n\n## 3.测试执行阶段\n\n## 4.测试总结阶段\n\n\n\n# 测试方法\n\n1.等价类\n\n2.边界值\n\n3.场景法\n\n4.因果图\n\n5.判定表\n\n6.路径覆盖法\n\n\n\n\n\n\n\n\n\n"},{"title":"bcrypt初识","url":"/2019/12/05/bcrypt初识/","content":"\n# 一、简介\n\nbcrypt是一个由两个外国人根据Blowfish加密算法所设计的密码散列函数。实现中bcrypt会使用一个加盐的流程以防御彩虹表攻击，同时bcrypt还是适应性函数，它可以借由增加迭代之次数来抵御暴力破解法。\n\n"},{"title":"mongodb初识","url":"/2019/12/03/mongodb初识/","content":"\n# mongodb安装与配置\n\n1.设置数据存储路径，没有可以新建文件夹\n\n\"C:\\data\\db\"\n\n2.配置环境变量\n\n将mongodb安装路径添加到 path中\n\n3.开启：\n\n命令行运行 mongod\n\n4.链接：\n命令行运行 mongo\n\n# mongodb数据库的基本概念\n\n- 数据库\n- 集合\n- 文档\n\n\n\n# 常用语句：\n\n1.查看所有数据库：\n\nshow dbs\n\n2.查看当前所在数据库:\n\ndb\n\n3.查看当前所在数据库中所有集合\n\nshow collections\n\n4.查看当前数据库相关信息（名称、文档个数、视图、索引、大小等）\n\ndb.stats();\n\n5.创建、打开、切换数据库\n\nuse 数据库名字\n\n![1575372080532](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1575372080532.png)\n\n当前没有 zywdb数据库，use了会新建，但是因为是空集合，所以并不会显示。\n\n插入一条数据\n\n`db.集合名.insertOne({})`\n\n`db.students.insertOne({\"name\":\"BuBu\"})`\n\n\n\n这个时候再 `show dbs` 显示所有数据库时候，才会显示刚刚use新建的数据库。\n\n![1575372278864](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1575372278864.png)\n\n\n\n注：use 这个命令很特殊，它具有打开、 切换、 创建数据库的功能：如果打开的这个数据库存在就是打开这个数据库。如果打开的是一个不存在的数据库，那么就会创建一个同名的数据库，但是：注意：既然是创建一个新的数据库，那么就必须向数据库中新增一个集合(collections【就像关系数据库中的表】)，并且插入一条数据（这样这个数据库才算创建成功）。\n\n如：往集合中插入一条数据。可以不用先创建集合，直接往里添加数据即可：\n`db.student.insertOne({\"name\": \"xiaoming\"})`\n\n\n\n\n\n6.展示当前数据库中所有的集合：\n\n`show collections`\n\n![1575372363932](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1575372363932.png)\n\n\n\n\n\n7.显示该集合中所有的数据\n\n`db.students.find()`\n\n![1575372449635](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1575372449635.png)\n\n\n\n8.删除当前所在数据库\n\n`db.dropDatabase();`\n\n\n\n# 在 node中使用 mongodb\n\n1.使用官方的mongodb包\n\n2.使用第三方 mongoose\n\n\n\n\n\n## 使用mongoose连接数据库\n\n### 1.导入\n\n`const mongoose = require(\"mongoose\")`\n\n### 2.连接\n\n连接到mongodb数据库，前提是mongodb数据库已经启动，这里的数据库名称可以是新建的也可以是已经存在的。\n\n**语法**：`mongoose.connect(uri, options);`\n\n`mongoose.connect(\"mongodb://localhost/itcast\")`\n\n**额外的属性设置**：\n\n\n\n```javascript\nmongoose.connect(\"mongodb://localhost/itcast\",{\n    \n})\n```\n\n\n\n\n\n### 3.设计表结构Schema，规定数据规范\n\n`var Schema = mongoose.Schema();`\n\n定义一个用户表结构，即一个`Schema`实例。 Schemas不仅定义了文档和属性的结构，还定义了文档实例方法、静态模型方法、复合索引和文档被称为中间件的生命周期钩子。\n\n默认语法：\n\n`var Schema = new Schema({},{})` \n\n有两个参数：\n\n1. 定义的数据规则\n2. 自定义的集合名字\n\n```javascript\nvar userSchema = new Schema({\n    username:{\n        type:String,\n        index:true// 直接定义索引\n    },\n    password:{...},\n    email:{...}，\n  \n});\n```\n\n—— 额外定义索引\n\n```javascript\nUser.index({\n    username: 1 / -1 (正向 和逆向 )\n});\n```\n\n—— 允许使用的 SchemaTypes\n\n- String\n- Number\n- Date\n- Buffer\n- Boolean\n- Mixed\n- ObjectId\n- Array\n\n—— `Schema` 不只是定义 文档结构 和属性类型，还可以定义\n\n- document 的instance methods【】\n- model 的 static Model methods【】\n- 复合索引【***】\n- 文档的生命周期钩子，也成为了中间件【】\n\n\n\n### 4.生成Model\n\n将文档结构发布为模型model，具体操作数据库的也是该`model`\n\n**语法**：`mongoose.model(modelName, schema)`\n\n第一个参数是： 一个**大写**的**名词单数**字符串用来表示你的**集合名称**，所以在这里的集合名称就是:**users**,生成规则是 **小写**+**改成复数**形式。\n\n第二个参数： 定义的表结构\n\n返回的是：模型构造函数，可以通过new生成实例\n\n`var User = mongoose.model('User',usersSchema);`\n\n注意： `.model()` 是对schema做了拷贝，要确保在调用`.model()` 之前所有的数据规则都已经添加完成。\n\n### 5.生成entity（document）\n\n通过 构造函数新建该集合下的一条数据\n\n```javascript\nvar admin = new User({\n    username:'杨静',\n    password:'12345',\n    email:\"123@qq.com\"\n});\n```\n\n\n\n6.保存该数据\n\n```javascript\nadmin.save((err,ret)=>{\n    console.log(\"保存成功\")\n});\n```\n\n\n\n运行之后可以通过语句查看\n\n![1575471311132](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1575471311132.png)\n\n也可以在可视化工具内查看\n\n![1575471143206](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1575471143206.png)\n\n\n\n# 操作语句\n\n在创建数据的过程中，我们有定义规则`Schema`，也有生成一个`Model`，明确区分 api的操作对象。\n\n`Schema`不具备操作数据库的能力。`Model`和`entity`都可对数据库操作造成影响，`Model`比`entity`更具操作性。\n\n1.获取到集合下的所有数据\n\n```javascript\nUser.find((err,res)=>{\n    console.log(res)\n});\n```\n\n2.获取到 特定的数据\n\n```javascript\nUser.find({name:\"/^zhang/\"},callback);// 获取所有name为“zhang”开头的数据\n```\n\n\n\n3. \n\n\n\n## 1.document自带实例方法\n\n\n\n## 2.自定义实例方法\n\n即是 对当前的Schema 实例的methods扩展方法。\n\n注意： 避免使用 箭头函数，会造成this 指向错误。\n\n```javascript\nuserSchema.methods.speak = function(){\n    cosnsole.log(\"Schema上的methods扩展方法-speak方法\")\n}\n\n```\n\n加在 Schema methods属性上的函数会编译到 `Model` 的prototype，也会暴露到每个`document`实例\n\n```javascript\nadmin.speak();// document调用methods上的methods拓展方法\n```\n\n\n\n\n\n## 3、静态方法\n\n注意：同样**不要**在静态方法中使用 ES6 箭头函数\n\n```javascript\n// Schema 定义\nuserSchema.statics.findByName = function(name,cb){\n    return this.find({name:new RegExp(name:\"i\")},cb);\n}\n// document 调用\nadmin.findByName(\"zhangye\",function(err,res){\n    console.log(res);\n})\n```\n\n\n\n\n\n## 虚拟值 Virtual\n\n作为document的属性，但是不会保存到MongoDB中，包含 getter 和 setter，getter可用于格式化和组合字段数据，setter可以分解一个值到多个字段。\n\n**注意： 虚拟值无法 对数据查询和字段选择。**\n\n\n\n同样通过 `UserSchema` 定义\n\n```javascript\n//定义： 在 virtual(\"方法名\")\nuserSchema.virtual(\"fullName\").get(function(){\n    return .....\n});\n// 调用 直接当做属性调用。\nvar fullname = admin.fullName;\n```\n\n"},{"title":"node资金系统","url":"/2019/12/02/node资金系统/","content":"\n\n\n# 实现的功能 和接口\n\n## 注册\n\n`/api/users/register`\n\n方法： POST\n\n根据注册使用的邮箱查找数据，若无则成功注册。若有，返回\"该邮箱已被注册\"提示。注册成功之后保存到mongodb数据库中。\n\n- 引入body-parser中间件获取POST传输数据\n\n```javascript\n1.引入\nconst bodyParser = require(\"body-parser\");\n2.配置（为啥要这样写）\napp.use(bodyParser.urlencoded({extended:false}));\napp.use(bodyParser.json());\n```\n\n\n\n- 密码加密保存：\n\n  使用 `bcrypt` 函数 `genSalt()` 。\n\n  语法：\n\n  ```javascript\n  bcrypt.genSalt(num,function(err,salt){\n      bcrypt.hash(password,salt,function(err,hash){\n          // 这里的hash 就是经过加密的密码，直接赋值给password即可。\n          \n      })\n  });\n  ```\n\n- mongodb 数据操作API\n\n  - `findOne` 只返回一个文档。相比较于`find` 是返回全部符合条件的文档\n\n  ```javascript\n  collection.findOne({查询条件},function(user){...});\n                                    \n  collection.findOne({查询条件}).then(user=>{});\n  ```\n\n  \n\n  - 保存一条数据\n\n  ```javascript\n  document.save()\n      .then(()=>{\"成功的回调\"})\n      .catch(err=>{\"保存失败\"});\n  ```\n\n  \n\n  \n\n\n\n## 登录\n\n`/api/users/login`\n\n方法：POST\n\n条件1：邮箱 条件2：密码。先核对邮箱，是否存在，不存在即：“输入账号不存在”,存在再验证密码。密码验证无误之后，为该用户添加token令牌。\n\n新知识点：\n\n1.使用jwt\n\n`jwt.sign(\"规则\",\"加密名字\",\"过期时间\",\"箭头函数\");`\n\n\n\n- 加密的密码验证\n\n`bcrypt.compare(用户输入的密码，数据库中的密码)`\n\n- 为字段添加token\n\n```javascript\n1.引入 jsonwebtoken\nconst jwt = require(\"jsonwebtoken\");\n2. 定义rule\nconst rule = {id:user.id,name:user.name};\n3.调用 jwt.sign()\njwt.sign(rule,keys.secretOrkey,{expiresIn:3600},function(err,token){\n    // 这里的token就是获取到的令牌\n});\n```\n\n\n\npassport： 验证token\n\n\n\n\n\n##  使用passport-jwt验证token\n\npassport-jwt是一个针对jsonwebtoken的插件，passport是express框架的一个针对密码的中间件\n\n### 1.安装\n\n`npm install passport-jwt -D` \n\n`npm install passport`\n\n### 2.导入\n\n在入口文件导入：\n`const passport  = require(\"passport\")`\n\n入口文件中初始化：\n`app.use(passport.initialize());`\n\n### 3.配置\n\n`config`文件夹下新建 passport.js文件。并在入口文件中导入\n\n`require(\"./config/passport\")(passport);`\n\n### 4.解析\n\n```javascript\nconst JwtStrategy = require('passport-jwt').Strategy,\n  \tExtractJwt = require('passport-jwt').ExtractJwt; // 导入包\nconst mongoose = require(\"mongoose\");\nconst User = mongoose.model(\"users\");\nconst keys = require('../config/keys');\nconst opts = {};\nopts.jwtFromRequest = ExtractJwt.fromAuthHeaderAsBearerToken();//通过配置信息生成jwt的请求，以此来验证 token\nopts.secretOrKey = keys.secretOrkey;\n\n \nmodule.exports = passport => {\n  passport.use(new JwtStrategy(opts, async function (jwt_payload, done) {\n    // console.log(jwt_payload);\n    const user = await User.findById(jwt_payload.id);\n    if (user) {\n      return done(null, user);\n    } else {\n      return done(null, false);\n    }\n  }));\n};\n```\n\n\n\n"},{"title":"mySQL初识","url":"/2019/12/01/mySQL初识/","content":"\n语义检查：\n\nDDL: 数据定义检查\n\nDCL:数据控制语言\n\nDML:数据操作语言\n\nDQL:数据查询语言\n\n\n\n\n语句：\n\n`select user,host from mysql.user`\n\n![1575208996232](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1575208996232.png)\n\n\n\n新建zyw库\n\n`create database zyw`\n\n创建zyw表\n\n`create table zyw;`\n\n删除库\n\n`drop database zyw`\n\n"},{"title":"node-服务器开启","url":"/2019/11/28/node-服务器开启/","content":"\n\n\n# 一，express开启\n\n`var express = require(\"express\")`\n\n`var app = express()`\n\n`app.get('/',function(req,res){console.log(\"您进入了/链接\")})`\n\n`app.listen(5000,function(err){console.log(\"servering is on port 5000\")})`\n\n\n\n\n\n\n\n链接出现的问题\n\n![1574918487494](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1574918487494.png)\n\n![1574918544028](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1574918544028.png)"},{"title":"CCSS之大坑","url":"/2019/10/18/CCSS之大坑/","content":"\n#  body 的背景\n\n\n\n# 基线的理解\n\n好复杂\n\n## line-height\n\n\n\n## vertical-align\n\n一个元素如果子元素出现行盒，该元素内部也会产生参考线。\n\n决定参考线：font-size,font-family , line-height \n\nvertical-align：\n\nbaseline：基线对齐\n\n\n\n\n\n"},{"title":"canvas做画板","url":"/2019/10/16/canvas做画板/","content":"\n\n\n\n\n一则公开课，有助于复习canvas。\n\n```javascript\nvar drawingBoard = {\n    cavs: document.getElementById('cavs'),\n    ctx: document.getElementById('cavs').getContext('2d'),\n    btn_container: document.getElementsByTagName('ul')[0],\n    bool: false,\n    colorBtn: document.getElementById('colorChange'),\n    lineRuler: document.getElementById('lineRuler'),\n    imgsArr: [],\n    init: function () {\n        // 1. 修改了线条的一些样式（不是用户通过按钮更改的）\n        this.ctx.lineCap = 'round';//线条起始和结尾样式\n        this.ctx.lineJoin = 'round';//转弯\n        // 2.执行 drawing 事件，事件中对鼠标悬停、按下、移动、离开都绑定了事件\n        this.drawing();\n        // 3. 给所有的 按钮绑定事件\n        this.btnsAllFn();\n    },\n    drawing: function () {\n        var self = this,\n            cavs = this.cavs,\n            //  获取到 画布左上点的位置坐标\n            c_left = cavs.offsetLeft,\n            c_top = cavs.offsetTop;\n        /* console.log(c_left, c_top); */\n\n        this.cavs.onmousedown = function (e) {\n            self.bool = true;\n            //  鼠标按下的距离是相对于浏览器的，所以要捕获到在画布内的位置还需要减去 画布在浏览器的位置\n            //  将画笔移动到该位置\n            var c_x = e.pageX - c_left,\n                c_y = e.pageY - c_top;\n            self.ctx.beginPath();\n            self.ctx.moveTo(c_x, c_y);\n\n            // 每次按下 都保存到数组中，为之后的撤销操作保留数据\n            var img = self.ctx.getImageData(0, 0, self.cavs.offsetWidth, self.cavs.offsetHeight);\n            self.imgsArr.push(img);\n            console.log(self.imgsArr);\n\n        };\n        this.cavs.onmousemove = function (e) {\n            if (self.bool) {\n                self.ctx.lineTo(e.pageX - c_left, e.pageY - c_top);\n                self.ctx.stroke();\n            }\n        };\n        this.cavs.onmouseup = function (e) {\n            self.ctx.closePath();\n            self.bool = false;\n\n        };\n        this.cavs.onmouseleave = function (e) {\n            self.ctx.closePath();\n            self.bool = false;\n        };\n    },\n    btnsAllFn: function () {\n        var self = this;\n        this.btn_container.onclick = function (e) {\n            switch (e.target.id) {\n                case 'cleanBoard':\n                    //清屏\n                    self.ctx.clearRect(0, 0, \n                                       self.cavs.offsetWidth, \t\t\t\t\t                      \t\t\t\t\t\t\tself.cavs.offsetHeight);\n                    break;\n                case 'eraser':\n                    //橡皮\n                    self.ctx.strokeStyle = '#ffffff';\n                    break;\n                case 'rescind':\n                    //撤销\n                    if (self.imgsArr.length > 0) {\n                        self.ctx.putImageData(self.imgsArr.pop(), 0, 0);\n                    }\n                    break;\n            }\n        };\n        this.colorBtn.onchange = function () {//颜色改变\n            console.log(this.value)\n            self.ctx.strokeStyle = this.value;\n        };\n        this.lineRuler.onchange = function () {//粗细改变\n            self.ctx.lineWidth = this.value;\n        };\n\n    }\n};\ndrawingBoard.init();\n```\n\n","tags":["公开课","canvas"]},{"title":"CSS选择器之表单样式中的妙用","url":"/2019/10/15/CSS选择器之表单样式中的妙用/","content":"\n\n\n# CSS 样式+ 表单样式\n\n又名：复习不常用的CSS选择器\n\n最近沉迷于样式编写，发现不仅一些动画效果和样式切换可以完全使用CSS编写，而且通过相对单位rem，vw，vh 简单获取到设备宽高度简化了js 的使用。\n\n\n\n\n\n##  + \n\n`eleA + eleB` :选择 eleA 元素之后紧跟的每个 eleB元素，即 兄弟元素\n\n\n\n\n\n## ~\n\n`eleA ~ eleB` 选择器 eleA  之后出现的所有 eleB，但是 eleB不必直接紧随 eleA。即 eleB 可以是子级，也可以是子级的子级.\n\n\n\n\n\n例子后续补充（以表单元素为例","tags":["CSS"]},{"title":"jQuery 补充知识","url":"/2019/10/12/jQuery-补充知识/","content":"\n\n\n\n\n一、隐式迭代\n\n即 如果选出一组jq对象，设置样式的话，不同 for循环可以统一设置(相同的操作)。（不完全理解仅做插眼知识点）\n\n适用场景： 排他\n\n例子：只有当前选中有特殊样式，切换的时候样式回复默认\n\n\n\n\n\n<!--more-->\n\n二、CSS 对象形式修改样式，样式名可以不加引号，样式属性值如果是 数字的话也可以不加引号，数字之外的值必须加引号。\n\n\n\n三、事件切换：`hover()`\n\n整合了mouseover 和mouseout，鼠标经过和鼠标离开两个事件 。\n\n\n\n并且：如果hover中只写了一个函数，那么鼠标经过和鼠标离开都会执行这个函数。\n\n例子：\n\n```javascript\n$('.nav>li').hover(function(){\n    $(this).children(\"ul\").slideToggle();\n    // 即鼠标经过和离开 都会进行 滑动的切换。\n})\n```\n\n优化：\n\n```java\n$('.nav>li').hover(function(){\n    $(this).children(\"ul\").stop().slideToggle();\n    // 默认实惠执行动画队列里的所有动画，会有一种抽风的感觉。\n    //加上 .stop() 即执行最近一次的动画，\n})\n```\n\n\n\n\n\n获取属性：\n\nprop() 固有属性 a 的href title\n\nattr() 自定义属性譬如：class  id \n\n\n\n获取input 的值\n\n`val()`\n\n表单元素修改事件：`change()`\n\n\n\n保留小数\n\n`toFixed(num)`  保留num 位小数\n\n\n\nsubstr(num): 原生js方法，在字符串中抽取从 *start* 下标开始的指定数目的字符。\n\n\n\n\n\nJquery元素遍历（进行不同的操作）\n\n`$(\"div\").each(function(index , domEle){ })` index是每个元素的索引号，domEle是每个DOM元素对象，不是jQuery 对象。\n\n\n\n\n\n$.each() 和上面的一样，不过这个遍历方法更多的用来遍历数据，譬如数组、对象等。\n\n\n\n元素位置的获取和设置\n\n1. `offset()` 设置或返回被选元素相对于**文档**的偏移坐标，跟 父级没有关系。 该方法有两个属性：left、top, `offset().top` 用于获取距离文档顶部的距离，`offset().left` 用于获取居里文档左侧的距离。\n\n   使用对象来一起设置 顶部和左侧的偏移\n\n   ```javascript\n   $('div').offset({\n       top:10,\n       left:10\n   });\n   ```\n\n   \n\n2. `position()` 返回的距离带有定位父级的距离\n\n\n\n\n\n\n\n获取 滚动距离 \n\n页面滚动事件：`$(window).scroll(function(){...})` \n\n设置/ 获取 页面滚动距离`$(document).scrollTop()` \n\n\n\n\n\n带有动画的返回顶部，需要操作`body,html` (只有元素才能动画，不能操作 document)\n\n```javascript\n$('body,html').animate({\n    'scrollTop':0\n});\n```\n\n\n\n\n\n实现 对象拷贝\n\n`$.extend([deep],target,object,[objectN])` \n\n1.  deep 如果设置为true为深拷贝，默认为false 浅拷贝\n2. target要拷贝的目标对象\n3. 待拷贝到第一个对象的对象 "},{"title":"max-height","url":"/2019/09/16/max-height/","content":"\n\n\n# 引论\n\n 今天在看的公开课，功能是实现 一个带鼠标悬停会出现旋转的二级菜单的 CSS导航栏。\n\n出现的一个问题，是 鼠标滑过 一级菜单时 二级菜单会旋转着出现。鼠标离开二级菜单会旋转着消失（`transform:rotateY(0deg)` ) 当鼠标再次滑过二级菜单的位置时（二级已经消失），二级菜单仍然会再次出现。这不符合预期。只有滑过一级菜单，对应的二级菜单才应该出现。\n\n\n\n解决方法：`max-height` 设为0 。\n\n# 方法\n\n重新学习些 `max-height`\n\n","tags":["CSS"]},{"title":"canvas笔记","url":"/2019/09/14/canvas笔记/","content":"\n\n\n# 1.基础的api\n\n`ctx.beginPath();` // 开始路径绘制 ，如果没有设置，接下来所有画的线条都会秉持一个样式，相当于画别的东西的时候重新拿个笔。\n\n如果 需要绘制多条属性颜色不一样的线条，需要重新开启新路径。不然属性颜色会被覆盖。\n\n`ctx.moveTo(20, 20);` // 设置路径起点，坐标为(20,20) ，**相当于落笔的坐标**\n\n`ctx.lineTo(200, 20);` // 绘制一条到(200,20)的轨迹，**到这时线条都是看不见的。**\n\n`ctx.lineWidth = 1.0;` // 设置线宽 \n\n`ctx.strokeStyle = '#CC0000';` // 设置线的颜色 \n\n<!--more-->\n\n`ctx.stroke();` // 进行线的着色，**这时整条线才变得可见**\n\n`ctx.closePath();` //自动绘制一条当前点到起点的直线，形成一个封闭图形，省却使用一次lineto方法。 它和 `beginPath` 并不是对应的。应用：三角形自动闭合。\n\n`ctx.fill()` 填充，绘制实心圆的时候，相对应的这类图形设置样式也应该用`ctx.fillStyle()` \n\n## 初例：\n\n```javascript\nctx.moveTo(100,100);\nctx.lineTo(100,200);\nctx.lineTo(200,200);\nctx.lineTo(200,300);\nctx.closePath();\nctx.stroke();\n```\n\n![](http://m.qpic.cn/psb?/V12zWOB84PDljA/ars07*g9.UBrnE1do.79DWy5Olz0GHujMXKIMNLe4o0!/b/dL8AAAAAAAAA&bo=0gE7AQAAAAADB8s!&rf=viewer_4)\n\n 如果将上述实例中的 `closePath()`改为`fill()`\n\n![](http://m.qpic.cn/psb?/V12zWOB84PDljA/6wYyWixEFnQbHbdB2f0PfuGMnuShU58lBMqUJ47TddA!/b/dL8AAAAAAAAA&bo=XAKSAQAAAAADF*8!&rf=viewer_4)\n\n还有一些独特的api ，绘制一些常用的图形而不需要我们手动计算距离再  重复lineTo。\n\n以下\n\n# 2.绘制矩形：\n\n## 实心矩形\n\n`ctx.fillRect(x,y,width,height)`它的四个参数分别为矩形左上角顶点的x坐标、y坐标，以及矩形的宽和高。fillStyle属性用来设置矩形的填充色。\n\n初例：\n\n```javascript\nctx.fillStyle = 'orange';\nctx.fillRect(50, 50, 200, 100); \n```\n\n![1568255521049](http://m.qpic.cn/psb?/V12zWOB84PDljA/JaEauoThKfvc7ZA0cLAnmM7TvYBBmf6yHOO9diZCn38!/b/dLYAAAAAAAAA&bo=0QE8AQAAAAADF98!&rf=viewer_4)\n\n其中，左上顶点 坐标为 （50,50），矩形宽为200，高为100。\n\n## 空心矩形\n\n`ctx.strokeRect(x,y,width,height)`\n\n实例：\n\n`ctx.strokeRect(50, 50, 200, 100); `\n\n![1568255652273](http://m.qpic.cn/psb?/V12zWOB84PDljA/uL5WhlXnY7DnxcPFynhqkweY.XBeErH7JQ43eQ*dYeQ!/b/dL4AAAAAAAAA&bo=zAE3AQAAAAADF8k!&rf=viewer_4)\n\n## 清除矩形区域\n\n`ctx.clearRect(x,y,width,height); ` 可以用来制造 某种被挖空的效果图。\n\n【实例】：\n\n```javascript\nctx.fillStyle = 'orange';\nctx.fillRect(50, 50, 200, 100); \nctx.clearRect(100,60,50,50); \n```\n\n![1568255818222](http://m.qpic.cn/psb?/V12zWOB84PDljA/D9CP*FU1.kPKPdjT8BoajsJCbdogLytVwbTnfRUziQ0!/b/dL8AAAAAAAAA&bo=zwE3AQAAAAADF8o!&rf=viewer_4)\n\n\n\n# 3.绘制文本\n\n`fillText(string, x, y)` 三个参数分别为文本内容、起点的x坐标、y坐标。使用之前，需用font设置字体、大小、样式（写法类似与CSS的font属性）。与此类似的还有`strokeText`方法，用来添加空心字。\n\n【实例】\n\n```javascript\n // 设置字体\nctx.font = \"Bold 20px Arial\"; \nctx.font = '微软雅黑'\n// 设置对齐方式\nctx.textAlign = \"left\";\n// 设置填充颜色\nctx.fillStyle = \"#008600\"; \n// 设置字体内容，以及在画布上的位置\nctx.fillText(\"Hello!\", 10, 50); \n// 绘制空心字\nctx.strokeText(\"Hello!\", 10, 100);\n//文字的 direction     有两个属性值：rlt，ltr\nctx.direction\n//设置基线\nctx.textBaseline\n//文字的对齐方式\nctx.textAlign = 'center';// 注意，文字对齐的基准点是strokeText 的时候设置的坐标。默认是start,和direction有关，如果是rtl，start 和left表现一致。如果是ltr，start个right表现一致。left 是 文字的左边靠近基准点，right 是 文字的右边靠近基准点，center 是文字的中间靠近基准点。还有个end值。\n\n```\n\n![1568256011815](http://m.qpic.cn/psb?/V12zWOB84PDljA/UpebxomoyvnKc0pyS5LiiOL7rOmPezyR15auziYzjl8!/b/dL8AAAAAAAAA&bo=awIVAQAAAAADF08!&rf=viewer_4)\n\n**注意**：`fillText`方法不支持文本断行，即所有文本出现在一行内。所以，如果要生成多行文本，只有调用多次`fillText`方法。\n\n# 4.绘制圆形 和扇形\n\n`arc`方法用来绘制扇形\n\n`ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);`\n\nx和y参数是圆心坐标，radius是半径，`startAngle`和`endAngle`则是扇形的起始角度和终止角度（**以弧度表示**），`anticlockwise`表示做图时应该逆时针画（true）还是顺时针画（false）;\n\n弧度计算：π  / 180\n\n## 实心圆\n\n```javascript\nctx.arc(60, 60, 50, 0, Math.PI*2, true); \nctx.fillStyle = \"#000000\"; \nctx.fill();\n```\n\n![1568256513032](http://m.qpic.cn/psb?/V12zWOB84PDljA/3ehflGSL6LSE8dQrb0550xjLRdMCOziXkZOJxntFFao!/b/dMUAAAAAAAAA&bo=YgIHAQAAAAADF1Q!&rf=viewer_4)\n\n## 空心圆（圆圈）\n\n```javascript\nctx.arc(60, 60, 50, 0, Math.PI*2, true);\nctx.lineWidth = 3; // 设置宽度\nctx.strokeStyle = \"#000\"; // 设置颜色\nctx.stroke();\n```\n\n![1568256523862](http://m.qpic.cn/psb?/V12zWOB84PDljA/c56wkEpfL8oyIzkbcynfPjNhvtSBezK5r9Kx.R8H3Sw!/b/dMMAAAAAAAAA&bo=XgHlAAAAAAADF4g!&rf=viewer_4)\n\n# 5.生成渐变色\n\n`ctx.createLinearGradient(x1,y1,x2,y2)` 参数是(x1, y1, x2, y2)，其中x1和y1是起点坐标，x2和y2是终点坐标。通过不同的坐标值，可以生成从上至下、从左到右的渐变等等。\n\n通过`addColorStop()` 设置不同时间段的颜色。\n\n可以通过`myGradient.addColorStop(0, color1);` 和 \n`myGradient.addColorStop(1, color2);` 设置0和100%的样式，也可以多分几段`myGradient.addColorStop(0.5, color);`\n\n注意： 生成一个渐变色 实例，对实例进行赋值颜色，使用api `addColorStop`\n\n【生成案例】\n\n```javascript\nvar myGradient = ctx.createLinearGradient(0, 0, 0, 160); \nmyGradient.addColorStop(0, \"#BABABA\"); \nmyGradient.addColorStop(1, \"#636363\");\n```\n\n【使用】\n\n绘制一个从上往下渐变色的矩形。\n\n矩形还是照常画，只不过 设置颜色的时候 将生成的渐变色实例赋值过去就可以。\n\n```java\nvar myGradient = ctx.createLinearGradient(0, 0, 0, 160); \nmyGradient.addColorStop(0, \"red\"); \nmyGradient.addColorStop(1, \"black\");\nctx.fillStyle = myGradient;\nctx.fillRect(10,10,200,100);\n```\n\n![1568256969356](http://m.qpic.cn/psb?/V12zWOB84PDljA/eT4RQA4O8kOMEA2j6SMrgtWatw1E0pWciCqnlNJmBTA!/b/dE0BAAAAAAAA&bo=ZQKhAQAAAAADF*U!&rf=viewer_4)\n\n# 7.生成阴影\n\n将画笔设置为带阴影，即画什么都有阴影\n\n`ctx.shadowOffsetX` // 设置水平位移\n\n`ctx.shadowOffsetY`  // 设置垂直位移\n\n`ctx.shadowBlur`  // 设置模糊度\n\n`ctx.shadowColor` // 设置阴影颜色\n\n【实例】\n\n绘制一个带阴影的红色矩形\n\n```javascript\nctx.shadowOffsetX = 10; // 设置水平位移\nctx.shadowOffsetY = 10; // 设置垂直位移\nctx.shadowBlur = 5; // 设置模糊度\nctx.shadowColor = \"rgba(0,0,0,0.5)\"; // 设置阴影颜色\n\nctx.fillStyle = \"#CC0000\"; \nctx.fillRect(10,10,200,100);\n\n```\n\n![1568258056066](http://m.qpic.cn/psb?/V12zWOB84PDljA/nx82MxCGD2LV8H7l.u.fizPZLmUgUlIuDLg0fHlrwd4!/b/dFQBAAAAAAAA&bo=BwGVAAAAAAADF6E!&rf=viewer_4)\n\n之后再绘制 其他图形也会带阴影。\n\n# 8.图像处理\n\nCanvas API 允许将图像文件插入画布，做法是读取图片后，使用`drawImage`方法在画布内进行重绘\n\n```javascript\nvar img = new Image();\nimg.src = 'image.png';\nctx.drawImage(img, 0, 0); // 设置对应的图像对象，以及它在画布上的位置\n\n```\n\n\n\n# 9.读取Canvas 内容\n\n`var imageData = context.getImageData(0, 0, canvas.width, canvas.height);`\n\n`imageData` 是一个对象，包含了每个像素的信息。\n\n以`ctx.fillRect(50,50,100,100)` 绘制的100*100 的矩形框为例。console 输出`imageData` 结果：\n\n![1568265201383](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\1568265201383.png)\n\n由此可见：其中包括 data，height，width ，data 是一个**一维数组**，该数组的值，依次是每个像素的红、绿、蓝、alpha通道值，因此该数组的长度= 图像的像素宽度* 图像的像素高度*4 ，每个值的范围在0 -255 。\n\n这个数组不仅可读，而且可写，因此通过操作这个数组的值，就可以达到操作图像的目的。修改这个数组以后，使用`putImageData`方法将数组内容重新绘制在Canvas上。\n\n1.获取：`ctx.getImageData`\n\n2.设置：`ctx.getImageData`\n\n\n\n# 10.配合js制作动画\n\n```javascript\nvar canvas = document.querySelector('canvas');\nvar ctx = canvas.getContext('2d');\nvar posX = 20,\n    posY = 100;\n\nvar timer = setInterval(function() {\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(0,0,canvas.width, canvas.height);\n\n    posX += 1;\n    posY += 0.25;\n\n    // ctx.beginPath();\n    ctx.fillStyle = \"white\";\n    ctx.arc(posX, posY, 10, 0, Math.PI*2, true); \n    // ctx.closePath();\n    ctx.fill();\n}, 30);\n\n```\n\n\n\ngif \n\n\n\n","tags":["canvas"]},{"title":"移动端开发","url":"/2019/09/06/移动端开发/","content":"\n\n\n","tags":["移动端"]},{"title":"CSS中引用的外部字体文件以及如何压缩","url":"/2019/09/06/CSS中引用的外部字体文件以及如何压缩/","content":"\n\n\n# 字体的几种格式\n\n- `.EOT`  微软创造的字体格式，只在IE6-IE8里使用，支持的浏览器：`internet Explorer 4.0+` \n- `.TTF`或`.OTF`，支持的浏览器：`IE9+,Firefox3.5+,Chrome4+,Safari3+,Opera10+,iOS Mobile Safari4.2+`\n- `.SVG/SVGZ`，使用矢量图改进的字体格式，体积更小，适合在手机设备上使用，支持的浏览器：`Chrome4+/Safari3.1+/Opera10.0+/IOS MObile Safari3.2+` \n- `.WOFF`  加载较快，支持的浏览器：`IE9.0+/FireFox3.5+/Chrome6+/Safari 3.6+/Opera11.1+` \n\n[在线转换字体格式](https://www.fontke.com/tool/convfont/) \n\n# 引用的方式\n\n- 使用 `@font-face` 定义字体属性，包括`font-family` 定义字体名字，`src` 文字引用地址，多个地址之间使用 逗号 隔开。\n\n  ```javascript\n  @font-face {\n        font-family: <YourWebFontName>;\n        src: <source> [<format>][,<source> [<format>]]*;\n        [font-weight: <weight>];\n        [font-style: <style>];\n  }\n  //  []包裹的是非必要属性\n  ```\n\n  \n\n- 有时候使用 两个url 导入字体文件是因为：绝大多数情况下，第一个 src 是可以去掉的，除非需要支持 IE9 下的兼容模式。在 IE9 中可以使用 IE7 和 IE8 的模式渲染页面，微软修改了在兼容模式下的 CSS 解析器，导致使用 ? 的方案失效。由于 CSS 解释器是从下往上解析的，所以在上面添加一个不带问号的 src 属性便可以解决此问题。\n\n# 使用 字蛛压缩字体文件\n\n- 安装 `npm install font-spider -g`\n\n- 在引用 字体文件的根目录下执行 `font-spider ./xx/index*.html` *号是针对所有html结尾的文件都进行压缩。\n\n  这样字体会被压缩，原件也会被保留。\t\n\n  注意：\n\n  - 如果文字有修改，需要再 重新压缩。（字蛛压缩原理是 挑出你用到的所有的字，没有用到的被踢出。）\n  - .ttf 文件必须存在 才能被压缩。","tags":["字体"]},{"title":"css之工作笔记","url":"/2019/09/03/css之疑惑/","content":"\n\n\n怕什么真理无穷，进一寸有一寸的欢喜。——可爱的博客er\n\n1. 布局页面的时候发现 上层盒子设置阴影会被下层盒子覆盖。搜索说 可以通过设置 `z-index` 更改层级，我这里更改无效。只能`position:relative`  相对于原来位置定位，原来的占位还是存在的。但为啥就让阴影显示出来了呢。\n\n2. 纯文本渲染输出 需要空格隔开：`letter-spacing:xxpx` 可跟normal、inherit、具体数值（允许负值）。不用傻乎乎的用 &nbps; 去一个个插入了吧。\n\n   Tips: `letter-spacing` 妙用\n\n   设置负值可以使得文本倒序。\n\n\n\n<!--more-->\n\n3.今天遇到一个动画问题。要求鼠标滑过的时候 导航栏中的文字下方要出现滑动的线条，且线条从左进，从右出。\n\n按照以往的思路 控制包裹文字的元素的宽度width从0到100% 就可以。但是在这里还不足够，因为是从同一个方向进和出。\n\n在这里，需要用到 transform的属性`transform-origin`，并且因为用到了transform，就不需要`width`，可以直接控制scale缩放比。默认是 100%，初始状态是 scale(0)，鼠标hover 的时候 `scale(1)`。\n\n相对应的。初始状态时`transform-origin:100% 50%` 结束的状态`transform-origin:0 50%`;\n\n```css\nnav ul li a::after{\n    content: \"\";\n    background-color: #000;\n    width: 100%;\n    transform:scale(0);\n    height: 2px;\n    position: absolute;\n    bottom: -36px;\n    left: 0;\n    transform-origin: 100% 50%;\n    transition: transform .25s;\n}\nnav ul li:hover >a::after{\n    transform:scale(1);\n    transform-origin: 0 50%;\n}\n```\n\n\n\n# \n\n","tags":["css"]},{"title":"软件扩——adobe xd","url":"/2019/09/03/软件扩——adobe-xd/","content":"\n\n\n工作需要 接触 Adobe XD\n\n可以直接下载Adobe Creative CLoud 窗口化进行 Adobe 系列产品的安装。\n\n<!--more-->\n\n\n\n### 1.设置主页：\n\n切换到原型，点击画板左侧图标变成蓝色，【首页】框 双击更换页面名字。\n\n您的用户会通过“主页”屏幕开始在应用程序或网站中进行导航。并且，如果您在预览原型时并没有选择任何内容，预览将从“主页”屏幕开始。\n\n![1568078180013](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\1568078180013.png)\n\n\n\n\n\n### 2.设置过渡原型\n\n就是点击页面跳转的意思。切换到 【原型】上，单击需要连接的对象，对象上出现带箭头的连接手柄。将鼠标悬停在手柄上，光标会变为连接器。单击并开始拖动鼠标，可以看到连接器。在目标画板或屏幕上释放鼠标。当您连接第一个元素时，该元素所在的画板将设为主画板。 \n\n\n\n### 3.网格编组。\n\n选中多个组件时，需要对整个 网格一起操作，可以进行【网格编组】，快捷键 Ctrl+R   ![1568079107002](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\1568079107002.png)\n\n在选中多个的同时，按下 Ctrl ，会显示 粉红色数值，显示的是对应的 上下左右的边距。\n\n![1568079181099](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\1568079181099.png)\n\n\n\n### 4.快捷键 Ctrl+3 \n\n会让你选中的画板 放大，且居中显示\n\n### 5.设置页面滚动\n\n设置页面滚动和 用户不需要拖动就能看到的内容范围。点击需要修改的画板名字，右侧会出现\n\n![1568079421937](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\1568079421937.png)\n\n将滚动改为 【垂直】。\n\n同时下拉页面，增加页面高度。\n\n通过 拉动 ![1568079498525](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\1568079498525.png)来控制 用户在进入页面的时候就能看到的内容范围。\n\n### 6.标题悬浮置顶\n\n切换至【原型】，选中标题栏部分，将![1568079964770](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\1568079964770.png)选项勾选。"},{"title":"响应式相关","url":"/2019/09/02/响应式相关/","content":"\n简单来说：不同的设备都能适配显示内容。\n\n# 之前涉及到的\n\n- 1.移动端单位改为rem 或者 em\n\n- 2.添加`<meta name=\"viewport\">` 设定宽度为设备宽度，最小宽度最大宽度等。\n\n  ```javascript\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  ```\n\n  <!--more-->\n\n# 新内容\n\n- 1，通过 css 控制不同设备（主要是宽度的检测）内容显示\n\n  具体： 在引入css 的时候，添加`media` 属性，通过该属性 可以设置该css样式什么时候有效\n\n  ```javascript\n  // 举例： 小于500px的时候显示 mobile移动端样式，大于500px的时候显示  pc端样式\n   <!-- pc端 -->\n   <link media=\"(min-width:500px)\" rel=\"stylesheet\" href=\"./1test_css/desktop.css\">\n   <!-- 手机端 -->\n   <link media=\"(max-width:500px)\" rel=\"stylesheet\" href=\"./1test_css/mobile.css\">\n  ```\n\n  即： 正常打开的时候显示的是 pc端样式。如果拉伸浏览器内可视宽度小于500px 的时候，就会使用mobile 样式。\n\n   拓展：`media query` 为媒体查询。贴一个别人的[blog](https://www.cnblogs.com/ouyangping/p/6415266.html)\n\n\n\n"},{"title":"ES6","url":"/2019/08/24/ES6/","content":"\n\n\n# 变量\n\nlet 和const 相同点是 ：1.不能重复声明 2.块级作用域\n\n## let：\n\n可以被修改\n\n## const\n\n不可以被修改。譬如一些常量 `Math.PI`\n\n<!--more-->\n\n# 函数\n\n## 参数的展开和拓展\n\n### ...args\n\n#### 1.剩余参数，必须是最后一个\n\n```javascript\nfunction func1(a,b,...args){\n    console.log(a);// 1\n    console.log(b);// 2\n    console.log(args);// [3,4] 在这里 ...args 即指代剩余的所有参数\n}\nfunc1(1,2,3,4);\n```\n\n#### 2.数组展开\n\n拆分为一个一个\n\n```javascript\nlet arr = [1,2,3];\n...arr 就等于 1 2 3  即将数组一个一个展开\n\n// 譬如定义 输出数组中每一个值的函数\nfunction func(arr){\n    for(var i = 0; i <arr.length; i ++){\n        console.log(i);\n    }\n}\n\n// 如果使用 数组展开的写法\n```\n\n也可用于两个数组的合并\n\n```javascript\nlet arr1 = [1,2,3,4];\nlet arr2 = [100,1000,1000];\nlet arr = [...arr1,...arr2];\n// 输出： [1,2,3,4,100,1000,10000]\n```\n\n\n\n## 默认参数\n\n```javascript\nfunction show(a,b=100,c=10){\n    // 直接在 形参后面=赋予默认值\n}\n```\n\n\n\n# 数组\n\n\n\n# 字符串\n\n\n\n"},{"title":"模拟前后端交互的小助手-mock&EasyMock","url":"/2019/08/24/模拟前后端交互的小助手-mock-EasyMock/","content":"\n\n\n# 说在前面\n\n- 知识储备：什么是跨域，为什么有跨域，如何解决跨域，在原生js和vue中分别如何处理跨域。网络请求和异步操作的关系，异步和同步的区分。\n- [mock](http://mockjs.com/) 是拦截Ajax 请求，生成随机数据返回\n- [EasyMock](https://easy-mock.com/) 提供一个网页手动输入数据就能生成接口\n\n<!--more-->\n\n# mock.js\n\n## 使用\n\n### 1.安装：\n\n`npm install mockjs` \n\n### 2.调用\n\n```javascript\nvar Mock = require('mockjs')\nvar data = Mock.mock({\n    // 属性 list 的值是一个数组，其中含有 1 到 10 个元素\n    'list|1-10': [{\n        // 属性 id 是一个自增数，起始值为 1，每次增 1\n        'id|+1': 1\n    }]\n})\n// 输出结果\nconsole.log(JSON.stringify(data, null, 4))\n```\n\n### 3.语法规范\n\nmockjs 是通过特殊的语法规范 随机生成数据，用户可以自定义数据模板。\n\n**数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：**\n\n`'name|rule': value`\n\n**注意：**\n\n- *属性名* 和 *生成规则* 之间用竖线 `|` 分隔。\n- *生成规则* 是可选的。\n\n#### 1.属性名\n\n#### 2.生成规则\n\n生成规则有 7 种格式：\n\n1. `'name|min-max': value`\n2. `'name|count': value`\n3. `'name|min-max.dmin-dmax': value`\n4. `'name|min-max.dcount': value`\n5. `'name|count.dmin-dmax': value`\n6. `'name|count.dcount': value`\n7. `'name|+step': value`\n\n- **生成规则 的 含义 需要依赖 属性值的类型 才能确定。**\n- *属性值* 中可以含有 `@占位符`。\n- *属性值* 还指定了最终值的初始值和类型。\n\n#### 3.属性值\n\n##### 1. 字符串 **String**\n\n1. `'name|min-max': string`\n\n   通过重复 `string` 生成一个字符串，重复次数大于等于 `min`，小于等于 `max`。\n\n2. `'name|count': string`\n\n   通过重复 `string` 生成一个字符串，重复次数等于 `count`。\n\n##### 2. 数字 **Number**\n\n1. `'name|+1': number`\n\n   属性值自动加 1，初始值为 `number`。\n\n2. `'name|min-max': number`\n\n   生成一个大于等于 `min`、小于等于 `max` 的整数，属性值 `number` 只是用来确定类型。\n\n3. `'name|min-max.dmin-dmax': number`\n\n   生成一个浮点数，整数部分大于等于 `min`、小于等于 `max`，小数部分保留 `dmin` 到 `dmax` 位。\n\n```\nMock.mock({\n    'number1|1-100.1-10': 1,\n    'number2|123.1-10': 1,\n    'number3|123.3': 1,\n    'number4|123.10': 1.123\n})\n// =>\n{\n    \"number1\": 12.92,\n    \"number2\": 123.51,\n    \"number3\": 123.777,\n    \"number4\": 123.1231091814\n}\n```\n\n##### 3. 布尔型 **Boolean**\n\n1. `'name|1': boolean`\n\n   随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率同样是 1/2。\n\n2. `'name|min-max': value`\n\n   随机生成一个布尔值，值为 `value` 的概率是 `min / (min + max)`，值为 `!value` 的概率是 `max / (min + max)`。\n\n##### 4. 对象 **Object**\n\n1. `'name|count': object`\n\n   从属性值 `object` 中随机选取 `count` 个属性。\n\n2. `'name|min-max': object`\n\n   从属性值 `object` 中随机选取 `min` 到 `max` 个属性。\n\n##### 5. 数组 **Array**\n\n1. `'name|1': array`\n\n   从属性值 `array` 中随机选取 1 个元素，作为最终值。\n\n2. `'name|+1': array`\n\n   从属性值 `array` 中顺序选取 1 个元素，作为最终值。\n\n3. `'name|min-max': array`\n\n   通过重复属性值 `array` 生成一个新数组，重复次数大于等于 `min`，小于等于 `max`。\n\n4. `'name|count': array`\n\n   通过重复属性值 `array` 生成一个新数组，重复次数为 `count`。\n\n##### 6. 函数 **Function**\n\n1. `'name': function`\n\n   执行函数 `function`，取其返回值作为最终的属性值，函数的上下文为属性 `'name'` 所在的对象。\n\n##### 7. 正则表达式 **RegExp** \n\n\n\n## EasyMock\n\n相比mockjs，EasyMock就是傻瓜式操作。打开官网即可-。-"},{"title":"致-所有的组件库们","url":"/2019/08/23/致-所有的组件库们/","content":"\n#  MUI\n\n[官网](http://dev.dcloud.net.cn/mui/) \n\n![1566538557061](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1566538557061.png)\n\n优点： 有底部tabbar、常用icon。\n\n缺点：是要下载复制到对应文件夹使用的，css样式和js需要手动导入。\n\n<!--more-->\n\n# mint-ui \n\n[官网](http://mint-ui.github.io/#!/zh-cn) \n\n![1566538694268](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1566538694268.png)\n\n优点：偏 移动端，譬如Toast 弹窗提示使用居多，messageBox提示框、选项卡、顶部Header、底部Tabbar、导航栏navbar\n\n\n\n# element-ui\n\n[官网](https://element.eleme.cn/#/zh-CN) \n\n\n\n# vux\n\n[一个凑合的 Vue.js 移动端 UI 组件库](https://vux.li/)\n\n目前所知是 不能在vue-cli中使用的\n\n\n\n# swiper 移动端触摸滑动组件\n\n使用\n\n`npm i --save swiper`\n\n```javascript\nlet scroll = new BScroll('.cat-wrapper',{\n    click: true\n})\n```\n\n\n\n使用必须条件：\n\n内容物由 content 包裹，且长度/宽度 必须大于最外层wrapper。","tags":["组件库"]},{"title":"CSS记账簿","url":"/2019/08/21/CSS记账簿/","content":"\n# CSS特性\n\n- 层叠性：处理冲突的时候，后面的会覆盖前面的\n- 继承性：子标签继承父标签的属性，譬如字体颜色，大小，\n- 优先级：选择器的权重计算\n\n# CSS 属性选择器\n\n- `~`  相同父元素下 所有目标元素\n\n  例子：\n\n  ```css\n  为所有相同的父元素中位于 p 元素之后的所有 ul 元素设置背景：\n  p~ul{\n  \n  　　background:#ff0000;\n  }\n  ```\n\n- `+` 紧跟的同类元素\n\n# css样式选择器\n\n<!--more-->\n\n## 1.属性选择器\n\n`div[attr]`: 选出所有带有attr属性的div\n\n`div[attr=attr1]`:选出 属性`attr`为`attr1`值的`div`\n\n`div[class=’class1’]`:选出`class`名为`class1`的`div`（完全等于）\n\n`div[class^=’class1’]`:选出`class`类名为`class1`开头的div\n\n`div[class$=’class1’]:`选出class名为`class1`结尾的div\n\n`div[class*=’class1’]`:选出class名包含有 class1的div（任意位置都可以）\n\n## 2.伪元素选择器\n\n::first-letter:选择第一个字\n\n::first-line:选出第一行\n\n::selection:改变选中文字的样式（默认的是蓝色白底）\n\n::before\n\n::after\n\n\n\n# 背景\n\nbackground-color: pink;\n\nbackground-image: url()\n\nbackground-repeat: no-repeat;// 是否重复\n\nbackground-position: 50% 50%; // 背景开始位置\n\nbackground-origin： padding-box|border-box|content-box //属性规定背景图片的定位区域。\n\nbackground-attachment:背景附着（fixed/scroll）拉动滚动轴时是否跟着移动\n\nbackground:合并写法\n\nbackground:rgba()\n\nbackground-size:百分比/ cover（自动调整缩放比例，保证图片始终填充满背景区域，如有溢出则被隐藏）/ contain（自动调整缩放比例，保证图片始终完整显示在区域内）\n\n注意：多背景图片，逗号隔开；如果要设置背景颜色，要把颜色设置在最后一组背景图片上，不然会不现实\n\n\n\n# flex布局\n\n## **一、含义：**\n\nFlex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。\n\n任何一个容器都可以指定为 Flex 布局。\n\n​\t\n\n```\n.box{ display: flex;}\n```\n\n行内元素也可以使用 Flex 布局。\n\n```\n.box{ display: inline-flex;}\n```\n\n **注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。**\n\n## 二、基本概念\n\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"**容器**\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"**项目**\"。\n\n![img](file:///C:\\Users\\ASUS\\AppData\\Local\\Temp\\ksohtml6988\\wps1.jpg)\n\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n\n### 1.容器的概念\n\n- lex-direction：决定主轴的方向（即项目的排列方向）\n\n- flex-wrap：默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行\n\n- flex-flow：flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n\n- justify-content：项目在主轴上的对齐方式\n\n- align-items：项目在交叉轴上如何对齐。\n\n- align-content：多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用\n\n### 2.项目的属性\n\n- order：定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\n- flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n\n- flex-shrink：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n- flex-basis：定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\n- flex：flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n-  align-self：允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\n\n\n# 清除BFC\n\n## BFC定义\n\n浮动的特性导致浮动元素不再占用源文档流的位置，导致对后续元素的排版造成影响。\n\n或者子集如果设置浮动属性导致脱离文档流父级高度为0的情况。\n\n## 方法：\n\n# 外边距塌陷\n\n1.给父元素加 1px的边框 or 内边距`padding`\n\n2.添加 `overflow：hidden` （触发BFC）\n\n\n\n\n\n# CSS3新特性\n\n（之前接触的比较零散，这里规整一下）\n\n## 新增的属性选择器：\n\n| 规则                | 说明                                    |\n| ------------------- | --------------------------------------- |\n| E[attr]             | 表示存在sttr属性即可                    |\n| E[attr=val]         | 表示属性值完全等于val                   |\n| E[attr*=val]        | 表示属性值包含val字符并且在**任意**位置 |\n| E[attr^=val]        | 表示属性值包含val字符并且在**开始**位置 |\n| E[attr$=val]        | 表示属性值包含val字符并且在**结束**位置 |\n| E:first-child       | 相同父元素下 第一个E子元素              |\n| E:last-child        | 最后一个子元素                          |\n| E:nth-child(n)      | 第n个子元素（n从  1开始                 |\n| E:nth-last-child(n) | 与 E:nth-child(n) 相同，只是是倒着计算  |\n| E:nth-child(2n+0)   | 需要满足 y = 2n+0 序列号 的元素         |\n\n## 目标伪类\n\n`E:target` 结合 锚点使用，处于当前锚点的\t元素会被选中。\n\n锚点有属性 href=“#text1”，点击锚点对应的text 会被增添上样式。 \n\n应用：\n\n## 伪元素选择器：\n\n`E:first-letter`：文本的第一个单词或字\n\n`E::first-line`：文本第一行\n\n`E::selection` 可改变选中文本的样式（鼠标左键按下选中时候的样式\n\n## 颜色表达方式\n\n- 直接英文名\n- rgb()\n- rgba()\n\n\n\n\n\n# 文本元素转换\n\n`text-transform`:改变文本的大小写\n\n`text-transform: capitalize(每个单词首字母大写)|uppercase（全部大写）|lowercase（全部小写）|inherit(IE 不支持)`\n\n\n\n# CSS属性兼容自动补齐\n\n- 全局安装 Autoprefixer\n\n  `npm install -g autoprefixer`\n\n- visual studio code 中安装插件`Autoprefixer`\n\n\n\n# CSS复位\n\n```java\n*{\nmargin:0;\npadding:0;\nbox-sizing:border-box;\n}\n```\n\n之后如果要继承 `box-sizing:border-box;` 后续代码则不需要添加。\n\n\n\n# 使用vw定制rem自适应布局(*)\n\n前景知识： 通过JS设置不同屏幕宽高比的 `font-size`，rem基于根元素`font-size`设置页面的字体大小，做到自适应。\n\n现在：结合 vw 单位 和`calc()`  \n\n\n\n# 排版竖行文字\n\n`writing-mode:horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr` \n\n`horizontal-tb`  正常的横向书写\n\n`vertical-rl` 竖写，并且从右往左\n\n`vertical-lr` 竖写，并且从左到右\n\n`sideways-rl`  内容垂直方向从上到下排列\n\n`sideways-lr` 内容垂直方向从下到上排列\n\n\n\n\n\n# 文字属性\n\n## 1.text-align\n\n设置文本样式，\n\n`text-align-last:justify` ，适用于 未知字数中文两端对齐\n\n`text-align:center`，文字居中，在input 输入框也可以通过\n\n这个设置光标居中\n\n## 2.line-height\n\n行高，\n\n可以设置好为 数值 `line-height:2` 即为两倍字体大小\n\n像素值：`line-height:10px`\n\n\n\n# 文本溢出隐藏并显示省略号\n\n```java\n// 只有一行文本的时候\noverflow:hidden; //超出的文本隐藏\ntext-overflow:ellipsis; //溢出用省略号显示\nwhite-space:nowrap; //溢出不换行\n```\n\n```javascript\n// 多行文本\noverflow:hidden; \ntext-overflow:ellipsis; \ndisplay:-webkit-box; \n-webkit-box-orient:vertical;\n-webkit-line-clamp:2\n```\n\n\n\n# 文本之间空隙\n\n`letter-spacing` 设置具体px可以将文字间隔开。\n\n妙用：设置负值，文本将倒序。\n\n恭喜发财 变成 财发喜恭\n\n\n\n# 左重右轻（只在flex）\n\n横向flex 布局时，最后一个加上`margin-left=auto` 可以实现最后一个图标向右对齐。\n\n效果\n\n![1567753062412](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\1567753062412.png)\n\n\n\n\n\n\n\n# attr抓取data-*\n\n一直以为attr 属性值只能在 js中通过api 获取。\n\ncss 中能直接通过 `attr(data-xx)` 获取到 用户自定义属性 `data-xx` 的值。在CSS中 同时使用 `content` 和`attr` 就能直接赋值。\n\n\n\n# 简单的表单验证\n\n用到的 知识点：伪元素   `:valid`  和  `:invalid` 和 `pattern`\n\n `:valid`   选择器在表单元素的值需要根据指定条件验证时设置指定样式\n\n​\t\t\t注意：只作用于能指定区间值的元素，例如 input 元素中的 min 和 max 属性，及正确的 email 字段, 合法的数字字段等。\n\n `:invalid` 相对的就是不符合指定条件时的样式 \n\n `pattern` 即 指定样式， 使用正则表达式、\n\n\n\n\n\n# :focus-within\n\n当元素本身或其后代获得焦点时，`:focus-within`伪类的元素就会有效。\n\n应用：button 获取被点击时切换颜色\n\n\n\n\n\n# 禁止右键操作\n\n整个页面禁止右键，在body上添加\n\n`oncontextmenu=self.event.returnValue=false onselect=\"return false\"`\n\n### 禁止鼠标右键保存图片\n\n```\n<img src=\"logo.png\" width=\"150\" height=\"150\" oncontextmenu=\"return false;\">\n```\n\n### 禁止鼠标拖动图片\n\n```\n<img src=\"logo.png\" width=\"150\" height=\"150\" ondragstart=\"return false;\">\n```\n\n### 文字禁止鼠标选中\n\n```\n<p onselectstart=\"return false;\">文字禁止鼠标选中</p>\n<p>普通文字可以选中</p>\n```\n\n### 禁止复制文本\n\n```\n<p onselect=\"document.selection.empty();\">禁止复制文本</p>\n<p>普通文字可以复制</p>\n```\n\n\n\n\n\n# 移动端尺寸基础知识\n\n[参考](https://www.cnblogs.com/chris-oil/p/5367106.html)\n\n安卓手机 ：360 *640 \n\niphone：主流：iphone6 ：375*667\n\n\n\n\n\n\n\n移动端开发的屏幕、图像、[字体与布局的兼容适配](https://juejin.im/post/5d70747cf265da03e16897c8)\n\n# querySelector方法\n\n方法返回文档中匹配指定 CSS 选择器的一个元素。仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 `querySelectorAll()` 方法替代。\n\n`querySelector` 接受的是一个CSS选择符、包括 class类名，id名，标签名， 后代选择器也可以用\n\n注意：\n\n- 接收的css选择符必须严格按照CSS选择符规范，类和ID均不能以数字开头。\n\n```javascript\nquerySelector('.btn')\nquerySelector('.wrap .con')\nquerySelector('#btn')\nquerySelector('button')\n```\n\n\n\n- `querySelector` 返回的是 `Static Node List` ，相比较于`getelementById` 获取的是实时的、动态的。\n\n\n\n# text-transform\n\n控制文本的大小写。\n\n属性值为：\n\n`capitalize`\t文本中的每个单词以大写字母开头。\n`uppercase`\t定义仅有大写字母。\n`lowercase`\t定义无大写字母，仅有小写字母。\n\n\n\n# clip-path \n\n利用坐标 绘制多边形，绘制方向是 顺时针，然后根据直线连起来。\n\n使用方法有两种 ：\n\n## 1） CSS  \n\n- 基础多边形：` .element { clip-path: ploygon(x1 y1, x2 y2, x3 y3, ...) }`\n\n- 圆形\n\n  `.element { clip-path: circle(r at x y) };`\n\n  r是圆的大小，x y 分别为愿新的坐标，可以用百分比\n\n- 椭圆\n\n  `.element { clip-path: ellipse(w h at x y) };`\t\n\n  r是圆的大小，h 为垂直高度，x y 为椭圆的圆心。\n\n- 矩形\n\n  `.element { clip-path: inset(x y z p) };`\n\n  为离top的距离 y为right的距离 z为bottom的距离 p为left的距离。跟多边形一样也是顺时针，跟多边形不同的是多边形是用边来使用的\n\n\n\n## 2） SVG\n\n```css\n.element { clip-path: url(\"选择器\")}\n```\n\n[详细的](https://www.jianshu.com/p/9890792dbc8b)\n\n\n\n\n\n# box-shadow\n\n语法：`box-shadow: 水平阴影的位置  垂直阴影的位置 模糊距离 阴影的大小 阴影颜色 内侧/外侧阴影`\n\n阴影叠加： 第一个是权重最高的。\n\n阴影的颜色： 继承父集的color\n\n\n\n# clip\n\n剪裁**绝对定位**元素。clip 允许您规定一个元素的可见尺寸，这样此元素就会被修剪并显示为这个形状。\n\n语法：`clip:rect(top,right,bottom,left)`\n\n参数含义：\n\n`top`：矩形上长对应父元素上长的距离(上长就是矩形上边的长)\n`right`： 矩形右宽对应父元素左宽的距离(右宽就是矩形右边的宽)\n`bottom`: 矩形下长对应父元素上长的距离\n`left`： 矩形左宽对应父元素左宽的距离\n\n[clip 和clip-path 有什么区别]()\n\nclip 只能裁剪正方形，必须要绝对定位。\n\nclip-path 对元素的定位没有要去，可以裁剪更多形状。\n\n\n\n# :not()\n\nCSS 否定伪类，:not(X)，是以一个简单的以选择器X为参数的功能性标记函数。它匹配不符合参数选择器X描述的元素。X不能包含另外一个否定选择器。\n\n:not伪类的优先级即为它参数选择器的优先级。:not伪类不像其它伪类，它不会增加选择器的优先级。\n\n**参数**：`:not()` 伪类可以将一个或多个以逗号分隔的选择器作为其参数。选择器中不得包含另一个否定选择符或伪元素。\n\n**应用**：商品列表中 当用户鼠标悬浮某一商品的时候，其他的同类商品都 模糊或者暗淡，突出当前用户选中的。\n\n【例子】：\n\nhtml结构\n\n```html\n<div class=\"wrapper\">\n    <div class=\"box\"></div>\n    <div class=\"box\"></div>\n    <div class=\"box\"></div>\n</div>\n```\n\ncss部分\n\n```css\n/* 当 wrapper 有hover的时候 子集 box 没有被hover 的时候，即除了hover之外的*/\n.wrapper:hover .box:not(:hover)  {\n    filter: blur(3px);\n  \topacity: 0.5;\n}\n\n```\n\n\n\n\n\n# 过滤filter()\n\n```\nfilter: none | blur() | brightness() | contrast() | drop-shadow() | grayscale() | hue-rotate() | invert() | opacity() | saturate() | sepia() | url();\n```\n\n[未应用](https://www.runoob.com/cssref/css3-pr-filter.html)\n\n\n\n\n\n# CSS复位\n\n```java\n*{\nmargin:0;\npadding:0;\nbox-sizing:border-box;\n}\n```\n\n之后如果要继承 `box-sizing:border-box;` 后续代码则不需要添加。\n\n\n\n# 使用vw定制rem自适应布局(*)\n\n前景知识： 通过JS设置不同屏幕宽高比的 `font-size`，rem基于根元素`font-size`设置页面的字体大小，做到自适应。\n\n现在：结合 vw 单位 和`calc()`  \n\n\n\n# 排版竖行文字\n\n`writing-mode:horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr` \n\n`horizontal-tb`  正常的横向书写\n\n`vertical-rl` 竖写，并且从右往左\n\n`vertical-lr` 竖写，并且从左到右\n\n`sideways-rl`  内容垂直方向从上到下排列\n\n`sideways-lr` 内容垂直方向从下到上排列\n\n\n\n# 居中两端对齐\n\n`text-align-last:justify` ，适用于 未知字数中文两端对齐\n\n\n\n# 文本溢出隐藏并显示省略号\n\n```java\n// 只有一行文本的时候\noverflow:hidden; //超出的文本隐藏\ntext-overflow:ellipsis; //溢出用省略号显示\nwhite-space:nowrap; //溢出不换行\n```\n\n\n\n# 文本之间空隙\n\n`letter-spacing` 设置具体px可以将文字间隔开。\n\n妙用：设置负值，文本将倒序。\n\n恭喜发财 变成 财发喜恭\n\n\n\n# 左重右轻（只在flex）\n\n横向flex 布局时，最后一个加上`margin-left=auto` 可以实现最后一个图标向右对齐。\n\n效果\n\n![1567753062412](C:\\Users\\Administrator\\AppData\\Roaming\\Typora\\typora-user-images\\1567753062412.png)\n\n\n\n\n\n\n\n# attr抓取data-*(搭配content )\n\n一直以为attr 属性值只能在 js中通过api 获取。\n\ncontent 属性与 :before 及 :after 伪元素配合使用，来插入生成内容。\n\ncss 中能直接通过 `attr(data-xx)` 获取到 用户自定义属性 `data-xx` 的值。在CSS中 同时使用 `content` 和`attr` 就能直接赋值。\n\n```javascript\nbutton::after {\n    content: attr(data-num);\n}\n<button data-num=\"123\"></button>\n```\n\n![1568086838980](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1568086838980.png)\n\n**Tip:** 只能赋值给 伪元素`::after` 或者 `::before`\n\n\n\n# 简单的表单验证\n\n用到的 知识点：伪元素   `:valid`  和  `:invalid` 和 `pattern`\n\n `:valid`   选择器在表单元素的值需要根据指定条件验证时设置指定样式\n\n​\t\t\t注意：只作用于能指定区间值的元素，例如 input 元素中的 min 和 max 属性，及正确的 email 字段, 合法的数字字段等。\n\n `:invalid` 相对的就是不符合指定条件时的样式 \n\n `pattern` 即 指定样式， 使用正则表达式、\n\n\n\n\n\n# :focus-within\n\n新的CSS伪类\n\n当元素本身或**其后代**获得焦点时，`:focus-within`伪类的元素就会有效。\n\n应用：button 获取被点击时切换颜色\n\n\n\n# filter（滤镜）属性\n\n```javascript\nfilter: none | blur() | brightness() | contrast() | drop-shadow() | grayscale() | hue-rotate() | invert() | opacity() | saturate() | sepia() | url();\n```\n\n## filter()\n\n\n\n\n\n# :valid  和:invalid校验表单\n\n需要搭配 `pattern` 使用，写在input 标签上\n\n\n\n# 单边框（box-shadow）\n\n1.左侧内置单边框\n\n![1568092442485](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1568092442485.png)\n\n```javascript\nbox-shadow:inset 5px 0 0 green;\n```\n\n\n\n# background-clip\n\n```\nbackground-clip: border-box|padding-box|content-box|text;\n```\n\n\n\n# 盒子阴影\n\n`box-shadow` 属性值包含：X偏移，Y偏移，阴影模糊半径，阴影扩散半径，和阴影颜色并以多个逗号分隔。由逗号分隔的列表来描述一个或多个阴影效果。该属性可以让几乎所有元素的边框产生阴影。如果元素同时设置了 `border-radius`，阴影也会有圆角效果。\n\n`box-shadow:offsetX offsetY blur-radius spread-radius color`\n\n## xy偏移量\n\nx 和y 偏移量都= 0 ，那么阴影位于元素后面。这时如果设置了`<blur-radius>` 或`<spread-radius>` 则有模糊效果\n\n`box-shadow: 0 0 10px 0 grey;`\n\n![1570283450517](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1570283450517.png)\n\n增加了 `inset` \n\n![1570283480457](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1570283480457.png)\n\n## 模糊半径\n\n模糊半径`blur-radius`  不能为负值。值越大，阴影越淡。\n\n扩散半径 为1px 和30px 的比较\n\n![1570284233038](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1570284233038.png)\n\n带上 inset 的效果\n\n![1570284255781](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1570284255781.png)\n\n## 扩散半径\n\n这是第四个值。取正值时，阴影扩大；取负值时，阴影收缩。默认为0，此时阴影与元素同样大。需要考虑 `inset` \n\n`spread-radius` 为1px  和30px  的效果\n\n![1570284140143](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1570284140143.png)\n\n带上 inset 的效果\n\n![1570284168610](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1570284168610.png)\n\n\n\n\n\n# 带图片的响应式图片容器\n\n功能：实现在宽度设置百分比的情况下，拖动浏览器下 demo保持**正方形**。同时内部image 不会被拉伸，同比例缩放。\n\n```css\n.demo {\n    /* background: #333; */\n    background-image: url('../images/feifei.jpg');\n    background-repeat: no-repeat;\n    background-position: center center;\n    background-size: cover;\n    width: 50%;\n}\n.demo::before {\n    content: '';\n    padding-top: 100%;\n    float: left;\n}\n.demo::after {\n    content: '';\n    display: block;\n    clear: both;\n}\n```\n\n原理： padding使用百分比是基于父级的宽度。没有给demo 高度，使用paddingTop 撑开，同时paddingTop 撑开的高度 = 父级宽度* 100% ，实现正方形。\n\n图片使用 backgroundImage 放入，设置 居于中心放置 ，使用 `cover` 。\n\n\n\n# table 布局的初使用\n\n`display:table` 子元素子父元素中水平垂直居中\n\n使用：1.父级设置`display:table`\n\n​\t\t   2.子集设置：\n\n```css\ndisplay:table-cell;\nvertical-align:middle;\ntext-align:center;\n```\n\n\n\n\n\n# object-fit\n\n\n\n\n\n# 滚动条样式美化\n\n`::-webkit-scrollbar` CSS伪类选择器影响了一个元素的滚动条的样式\n\n【但是 MDN 提示，该特征是非标准尽量不要在生产环境中使用。】\n\n- `::-webkit-scrollbar` — 整个滚动条.\n- `::-webkit-scrollbar-button` — 滚动条上的按钮 (上下箭头).\n- `::-webkit-scrollbar-thumb` — 滚动条上的滚动滑块.\n- `::-webkit-scrollbar-track` — 滚动条轨道.\n- `::-webkit-scrollbar-track-piece` — 滚动条没有滑块的轨道部分.\n- `::-webkit-scrollbar-corner` — 当同时有垂直滚动条和水平滚动条时交汇的部分.\n- `::-webkit-resizer` — 某些元素的corner部分的部分样式(例:textarea的可拖动按钮).\n\n\n\n# CSS中自定义属性\n\n`--*` CSS变量，带有`--`的前缀的属性名，表示的是带有值的自定义属性，其可以通过`var` 函数在全文档范围内复用。并且值将会借助级联算法和自定义属性值运算出来。\n\n举例：\n\n```css\n div{\n     /* 1.自定义属性 */\n     --percent:50;\n     /* width: 200px; */\n     height: 10px;\n     border-radius: 5px;\n     border: 1px solid;\n     /* 2.利用线性渐变实现进度条 */\n     background-image: linear-gradient(#0ff,#0ff);\n     background-repeat: no-repeat;\n     /* var 获取自定义属性的值 */\n     background-size: calc(var(--percent) * 1%);\n}\n```\n\n- `var` 获取到 `--percent` 定义的值\n-  `--percent` 定义的值 是可以被计算的 在这里 使用`calc` 计算成百分比\n\n\n\n并且：如果是同名的 自定义属性，使用在最近父级中被定义的。\n\n\n\n\n\n# outline 轮廓\n\n轮廓与边框在以下几个方面存在不同：\n\n- 轮廓不占据空间，它们被描绘于内容之上\n- 轮廓可以是非矩形的。在Gecko/Firefox中，轮廓是矩形的，但是Opera则会围绕元素结构绘制非矩形的形状，如下图\n\n- 包括 `outline-color` `outline-style` `outline-width` \n\n语法：\n\n```css\n/* 宽度 | 样式 | 颜色 */\noutline: 1px solid white;\n```\n\n\n\n\n\n# SVG\n\n可缩放的矢量图\n\n- 使用代码书写而成\n- 缩放不会失真\n- 内容轻量\n\n\n\n# 数据连接\n\n**data url**\n\n将目标文件的数据直接写在路径位置。\n\n语法：`data:MIME,数据`\n\n- 减少浏览器的请求\n- 减少响应时间\n\n缺点：\n\n- 不利于浏览器的缓存，会在刷新的时候重新请求\n\n一般针对 图片。\n\n\n\n## base64编码形式\n\n\n\n# 浏览器兼容性\n\n## 不通浏览器针对新的CSS3熟悉兼容\n\n可以用插件傻瓜式操作\n\n## 背景图多选一\n\n语法：\n\n```CSS\nbackground-image: image-set( \"cat.png\" 1x,\n                             \"cat-2x.png\" 2x,\n                             \"cat-print.png\" 600dpi);\n```\n\n## 针对IE的CSS前缀\n\n- `*` IE 5、6、6\n- `_` 兼容 IE5—IE6\n- `属性值\\9`  兼容IE5-IE10\n- `属性值\\0` 兼容IE8-IE10\n- `属性值\\9\\0`  兼容IE9-IE10\n\n IE 的外边距 BUG，浮动元素的左外边距翻倍。\n\n- \n\n\n\n","tags":["CSS"]},{"title":"移动端组件——better-scroll","url":"/2019/08/21/移动端组件——better-scroll/","content":"\n\n\n# 定义\n\n移动端 触摸滚动插件\n\n# 使用\n\n## 1.html结构：  \n\n必须有包裹，即`div.wrapper` 包裹 `div.content` 标签和类名不做需求。并且，内部`content` 高度/宽度 必须大于外部的盒子，才能拖动。\n\n## 2.JS部分： \n\n实例化 better-scroll 对象\n\n```javascript\nconst bscroll = new BScroll('.wrapper',{});\n```\n\n## 3.额外功能：滑动实时显示滑动的距离\n\n```javascript\n// 属性probeType设置，一共有4个值，0，1,2,3 ,0和1是不进行实时侦测位置，2是在手指滚动的过程中侦测，手指离开之后就不进行侦测，3是只要是滚动就侦测，手指离开之后有个惯性滚动，即在这个过程中也会侦测\nconst bscroll = new BScroll('.wrapper',{\n    probeType：3\n});\n\nbscroll.on('scroll',position =>{\n    console.log(position)\n});\n```\n\n## 4.内部点击事件。\n\n如果在wrapper内部有按钮或者需要点击事件的，点击会无法执行。需要额外增加click属性。\n\n```javascript\nconst bscroll = new BScroll('.wrapper',{\n    click:true\n});\n```\n\n## 5.上拉刷新：thresold\n\n```javascript\nconst bscroll = new BScroll('.wrapper',{\n   pullUpLoad:true\n});\nbscroll.on('pullingUp',()=>{\n    console.log('上拉显示更多')；\n    //发送网络请求，请求更多资源\n    //等请求完成，并且将新数据展示出来之后，必须执行  停止上拉加载更多 \n    bscroll.finishPullUp()\n})\n```\n\n## 6.封装 滚动组件，减少耦合\n\n```javascript\n<template>\n\t<div class=\"wrapper\" ref=\"wrapper\">\n    \t<div class=\"content\">\n        \t<slot></slot>\n        </div>\n    </div>    \n</template>\n\n<script>\n import BScroll from 'better-scroll'\n export default{\n\tdata(){\n        return {\n            scroll:null\n        }\n    },\n     mounted(){\n         this.scroll = new BScroll(this.$refs.wrapper,{\n             \n         })\n     }\n\t}         \n            \n</script>\n```\n\n引用该组件的时候，手动给最外层的盒子，添加高度或宽度"},{"title":"promise处理异步请求","url":"/2019/08/21/promise处理异步请求/","content":"\n\n\n# 定义以及使用\n\n## 前景知识：\n\n### 1.区分同步任务和 异步任务：\n\n程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。\n\n1.同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。\n\n2.异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。\n\n3.如何检测 异步操作结束，之前可以通过 回调函数、监听事件完成等，但存在 不利于阅读，各个部分高度耦合，程序结构混乱以及流程难以追踪。\n\n<!--more-->\n\n### 2.promise 提出的必要：\n\n1.原生JS 是 单线程的。遇到异步请求的时候 会整个程序停下来去处理这个异步操作，导致页面卡死。\n\n2.请求异步数据有时候并不是一步到位的。会在请求数据1 的返回操作中又去请求数据2，甚至3，造成 回调地狱。\n\n### 3.优点：\n\n1.代码可读性高，页面美观。\n\n2.充当 异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口 。使得异步操作写起来像 同步，而不必一层层嵌套回调。\n\n## 定义、本质\n\nPromise 是一个对象，也是一个构造函数。它 接收一个回调函数 作为参数，它返回的就是一个Promise 实例。\n\n它的设计思想是，所有异步任务都返回一个promise 实例，Promise 实例有一个`then` 方法，用来指定下一步的回调函数。\n\n```javascript\nfunction func(resolve,reject){\n    ....\n}\nfunction func2(){\n    ...\n}\nvar p1 = new Promise(func);\np1.then(func2)\n// 在这里就是 func1的异步操作执行完成之后，就会执行 func2，\n// 传统的写法是： 将 func2传入func1的，写成 func1(func2)。而 promise使得二者变成 链式写法，改善了可读性，并且使得 多层嵌套的回调函数变得方便。\n```\n\n传统的：\n\n```javascript\nstep1(function (value1) {\n  step2(value1, function(value2) {\n    step3(value2, function(value3) {\n      step4(value3, function(value4) {\n        // ...\n      });\n    });\n  });\n});\n```\n\n使用promise：\n\n```javascript\n(new Promise(step1))\n  .then(step2)\n  .then(step3)\n  .then(step4);\n```\n\n\n\n## 使用\n\n### 1.只处理一个请求\n\n```javascript\nnew Promise( (resolve,reject)=>{\n\t/* 异步操作，可以用setTimeout 代替模拟效果*/\n    resolve();\n    reject();\n})\n    .then(data=>{...})\n\t.catch(err=>{...})\n```\n\n`resolve` 和`reject` 是作为回调函数的参数传入的，且分别对应 回调成功 和回调失败。在获取数据的时候 ，仅仅调用这两个方法。而不具体如何操作。在 链式调用`.then()` 和 `.catech()` 的时候会具体处理返回的数据或者错误信息。\n\n```javascript\n// 另外一种写法。将 resolve和reject 的使用方法语句都写在 .then 中\nnew Promise((resolve,reject)=>{\n\tsetTimeout(()=>{\n        resolve('hello');\n        reject('err')\n    },1000)\n}).then( data=>{...},err=>{....})\n```\n\n### 2.多次链式调用\n\n```javascript\nnew Promise( (resolve,reject)=>{\n    setTimeout(()=>{\n        resolve('hello')\n        reject('err');\n    },1000)\n})\n.then(data=>{\n    console.log(data,'1次');\n    return new Promise(resolve=>{\n          resolve(data +'111');\n    })\n})\n.then(data=>{\n    console.log(data,'2次');\n    return new Promise(resolve=>{\n         resolve(data +'222');\n    })\n})\n.then(data=>{\n    console.log(data,'3次')\n})\n```\n\n结构划分：\n\n<img src=\"https://i.loli.net/2019/08/21/YNxrMQ9enkdsyLT.png\" width=\"300px\" height=\"400px\"></img>\n\n输出结果\n\n![1566357518944](https://i.loli.net/2019/08/21/kdyDKU7s9faJChe.png)\n\n**解释一下**： 后两个reject 省略了。是可选参数。所以后两个请求也就可以不用 `.catch` 了\n\n其中 2次请求数据  和3次请求数据 中 并没有使用 异步请求处理参数，所以可以直接调用 API： `Promise.resolve()`\n\n即：\n\n```javascript\n return new Promise( (resolve)=>{\n     resolve(...);\n  }).then()\n```\n\n可以简化成：（不需要 new 实例）\n\n```javascript\nreturn Promise.resolve(data+'222')\n```\n\n\n\n所以整个3次请求数据的语句又可以简化成：\n\n```javascript\nnew Promise( (resolve,reject)=>{\n    setTimeout(()=>{\n        resolve('hello')\n        reject('err');\n    },1000)\n})\n.then(data=>{\n    console.log(data,'1次');\n    //  因为 2次调用不涉及异步请求，直接调用 promise.resolve\n    return Promise.resolve(data+'111')\n})\n.then(data=>{\n    console.log(data,'2次');\n     // 直接调用 promise.resolve\n    return Promise.resolve(data+'222')\n})\n.then(data=>{\n    console.log(data,'3次')\n})\n```\n\n进一步简化： 省略 二次调用和三次调用的  `Promise.resolve`\n\n```javascript\n new Promise( (resolve,reject)=>{\n     setTimeout(()=>{\n         resolve('hello')\n         reject('err');\n     },1000)\n })\n.then(data=>{\n     console.log(data,'1次');\n     return (data+'111')\n })\n.then(data=>{\n     console.log(data,'2次');\n     return (data+'222')\n })\n.then(data=>{\n     console.log(data,'3次')\n })\n```\n\n\n\n\n\n### 3.同时处理2个异步请求\n\n使用`Promise.all`\n\n```javascript\nPromise.all([\n    // 第一个请求\n    new Promise((resolve,reject)=>{\n        setTimeout(()=>{\n            resolve('hello');\n        },1000)\n    }),\n    // 第二个请求\n    new Promise((resolve,reject)=>{\n        setTimeout(()=>{\n            resolve('world');\n        },1000)\n    })\n]).then(res=>{\n    // res[0] 为返回的第一个结果，\n    // res[1] 为返回的第二个结果\n    console.log(res[0]);\n    console.log(res[1]);\n})\n```\n\n输出结果：\n\n![1566369488626](https://i.loli.net/2019/08/21/k2z3TAiOlFbSXmU.png)\n\n用 `Easy Mock` 模拟了数据接口，在`Promise.all` 中 同时发起两个网络请求\n\n```javascript\n    Promise.all([\n        new Promise((resolve,reject)=>{\n            $.ajax({\n                url:\"https://easy-mock.com/mock/5d5ce77c7bd1911c17e50f80/getinfo\",\n                success:function(data){\n                    resolve(data)\n                }\n            })  \n        }),\n        new Promise((resolve,reject)=>{\n            $.ajax({\n                url:\"https://easy-mock.com/mock/5d5ce77c7bd1911c17e50f80/getnumbers\",\n                success:function(data){\n                    resolve(data)\n                }\n            })\n        })\n    ]).then(res=>{\n        // res[0] 为返回的第一个结果，\n        // res[1] 为返回的第二个结果\n        console.log(res);\n        console.log(res[0]);\n        console.log(res[1]);\n    })\n```\n\n输出结果 \n\n![1566370340912](https://i.loli.net/2019/08/21/m1tS83TxfLhXZUe.png)\n\n\n\n\n\n### 多个请求包装成一个promise实例\n\n`promise.race`\n\n\n\n\n\n\n\n在Vuex 中 `actions` 是处理异步操作的，就可以使用 promise 去处理。\n\n ","tags":["promise"]},{"title":"CSS之居中","url":"/2019/08/20/CSS之居中/","content":"\n# 前景知识\n\n- 明确区分块级元素、行级元素和行级块元素。\n- 熟悉块级元素和行级元素在布局上的不同和优势，以及如何手动更改。\n\n- 熟悉盒模型，以及如何手动更改 IE盒模型和怪异盒模型\n\n# 单一元素在浏览器中居中\n\n<!--more-->\n\n## 盒子\n\n​\t方法1：绝对定位之常规操作\n\n```javascript\n .box{\n     background-color: palegoldenrod;\n     width: 100px;\n     height: 100px;\n     position: absolute;\n     top: 50%;\n     left: 50%;\n     transform: translateX(-50%) translateY(-50%);\n     // transform 换成margin也可以，就是margin数值需要计算，遇到带小数的麻烦，transfrom直接-50%方便。\n }\n```\n\n方法2：绝对定位之全是0\n\n```javascript\n.box{\n    background-color: palegoldenrod;\n    width: 100px;\n    height: 100px;\n    position: absolute;\n    /* 全是0，绝对定位元素的自动伸缩的特性*/\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    margin: auto;\n}\n```\n\n\n\n方法3：flex布局\n\n```javascript\nhtml{\n    width: 100%;\n    height: 100%;\n}\nbody{\n    width: 100%;\n    height: 100%;\n    /* 主轴center，纵轴center，要注意高度要设置自适应不然纵轴无法center*/\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n.box{\n    background-color: palegoldenrod;\n    width: 100px;\n    height: 100px;\n}\n```\n\n\n\n## 行级元素\n\n\n\n# 元素内部居中\n\n## 方法1：绝对定位+父级相对定位（子绝父相\n\n```javascript\n.wrapper{\n    width: 500px;\n    height: 500px;\n    background-color: powderblue;\n    position: relative;\n}\n.box{\n    width: 100px;\n    height: 100px;\n    background-color: thistle;\n    /* 绝对定位之后，也可以使用上面全是0自适应的方法，不用拘泥 */\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translateX(-50%) translateY(-50%);\n}\n```\n\n\n\n## 方法2 ：margin +手动计算边距(小心 外边距塌陷咯~~)\n\n```javascript\n.wrapper{\n    width: 500px;\n    height: 500px;\n    background-color: powderblue;\n    /* position: relative; */\n    overflow: hidden;\n}\n.box{\n    width: 100px;\n    height: 100px;\n    background-color: thistle;\n    /*  */\n    margin: 0 auto;\n    margin-top: 200px;\n}\n```\n\n## 3.flex\n\n利用flex 的属性：\n\n```CSS\njustify-content: center;\nalign-items: center;\n```\n\n\n\n\n\n## 4.flex+ marginAuto\n\n利用 margin 自动撑到中间位置\n\n```css\n.wrapper {\n    width: 300px;\n    height: 300px;\n    border: 1px solid #ccc;\n    display: flex;\n}\nimg {\n    margin: auto;\n}\n```\n\n```html\n<div class=\"wrapper\">\n    <img src=\"./img/logo.png\" alt=\"\">\n</div>\n```\n\n## 5.table-cell\n\n```css\ndisplay:table-cell;\ntext-align: center;\nvertical-align: middle;   \n```\n\n## 6.absolute+ 四个方位值相等+marginAuto\n\n不一定四个方位值是0，必须定宽。\n\n宽度定了，margin为自适应，吸收剩余空间，把元素置于中间\n\n```css\np{\n    width:100px;\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    right: 0px;\n    bottom: 0px;\n    // margin不能漏了\n    margin: auto;\n}\n```\n\n\n\n## 7.grid\n\n父级：`display:grid`\n\n子集：`align-self: center;justify-self: center;`\n\n# 文本居中\n\n` text-align:center;` 文本居中显示\n\n`line-height: 500px;` 文本行高== 容器高度\n\n注意： 容器内 有多行文本 使用 `line-height: 500px;`  会导致每一行都是 容器高度，使得文字超出容器。\n\n最方便的还是另外设置一下容器包裹一下文字，知道文本高度在父容器上设置上下padding。enmmm 再看看有什么其他的方法。\n\n\n\n补充：多行文本居中\n\n方法：给文字容器设置 table布局\n\n```javascript\n .wrapper{\n     width: 500px;\n     height: 500px;\n     background-color: powderblue;\n\n     text-align: center;\n     vertical-align:middle;\n     display:table-cell;     \n }\n```\n\n# 图片居中\n\n## 1.line-hight 与verticalAlign 搭配\n\n**适用场景**：图片未知大小\n\n```javascript\n// CSS \n<style>\n    .container {\n        height: 250px;\n        width: 250px;\n        border: 1px solid #000;\n        line-height: 250px;\n        box-sizing: border-box;\n        text-align: center;\n        font-size: 0;\n    }\n    img {\n        vertical-align: middle;\n    }\n</style>\n// HTML \n <div class=\"container\">\n       <img src=\"../images/yaya.jpg\" alt=\"\">\n</div>\n\n// 因为 vertical-align:middle 是设置元素的中垂点 = 父级的基线 + 1/2 父元素中字母X的高度 \n// 英文字母X在父元素中并不居中，且每个字体的字符X的高低位置不一致。\n//  所以在这里我们需要设置 fontSize 为0。\n```\n\n## 2.flex 布局\n\n适用： 图文混排。左边是图片，右边的文字，文字多少未知，图片垂直居中。\n\n```css\ndisplay:flex;\njustify-content:center;\nalign-items:center;\n```\n\n\n\n## 3.利用伪元素\n\n```html\n<div class=\"wrapper\">\n    <img src=\"./img/logo.png\" alt=\"\">\n</div>\n```\n\n```css\n.wrapper {\n    width: 300px;\n    height: 300px;\n    border: 1px solid #ccc;\n    text-align: center;\n}\n\n.wrapper::after {\n    content: '';\n    display: inline-block;\n    vertical-align: middle;\n    height: 100%;\n}\n\n.wrapper > img {\n    vertical-align: middle;\n}\n```\n\n\n\n\n\n\n\n"},{"title":"rotate和rotate3d","url":"/2019/08/19/rotate和rotate3d/","content":"\n\n\n\n\n# rotate\n\n平面的。\n\n![](https://mdn.mozillademos.org/files/3548/transform-functions-rotate_19.5.png)\n\n旋转角度为正，则顺时针运动，反之逆时针。\n\n\n\n# rotate3d\t\n\n立体的。"},{"title":"px、em和rem","url":"/2019/08/18/CSS中常用的几个单位/","content":"\n# px\n\npx（像素）单位，作为具体的数值，设置长宽高和字体大小的时候比较精确和固定。\n\n问题：1、固定长宽高在不同设备上打开会出现页面布局错误。2.固定的字体大小在改变浏览器大小的时候也会导致原有的页面布局被打破。\n\n\n\n# em\n\nem作为一个相对值，是**基于父元素的字体大小** 设置的，而且作为 一个相对值也是一个比例，计算公式\n\n实际的字体像素值：`em *(父元素的fontSize值)` \n\n一个简单的栗子：\n\n三级嵌套的div，内设文字，问题的字体大小都为 `font-size:1.5em;` 可以看到 文字的大小 是逐级增大的，每次的字体大小值都是基于上一个（即父元素）的fontSize\n\n```javascript\n<style>\n    div{\n        border: 1px solid #000;\n    }\n    body,html{\n        font-size: 10px;\n    }\n    div .top{\n        // 每一层文字 大小 都是 父级的 1.5倍\n        font-size:1.5em;\n    }\n    div .middle{\n        font-size:1.5em;\n    }\n    div .bottom{\n        font-size:1.5em;\n    }\n</style>\n// 嵌套的三级div\n<div class=\"top\">\n        top\n        <div class=\"middle\">\n            middle\n            <div class=\"bottom\">\n                bottom\n            </div>\n        </div>\n    </div>\n```\n\n效果演示：\n\n![](https://i.loli.net/2019/09/04/gzewnPXYW6lS8Is.png)\n\n\n\n\n\n\n\n# rem\n\nrem也是一个相对值，但与`em`不同的是，`rem`是基于**页面根元素html**的。当给html设置一个统一的fontSize 之后，之后的元素设置一个相对值，后续更改也会简单。\n\n```javascript\n// 给html 设置 62.5%的fontSize，即62.5% * 16px = 10px\nhtml { font-size:62.5%}\nbody {font-size: 1.4rem;}  /*1.4 × 10px = 14px */\nh1 { font-size: 2.4rem;}  /*2.4 × 10px = 24px*/\n```\n\n\n\n\n\n# viewport width & viewport height\n\n基于浏览器 可视区大小（浏览器去掉任务栏，滚动轴的那个空白界面）\n\n值基于 1~100之间，50vw 即使画面宽度的一半\n\n\n\n\n\n# vmin  & vmax\n\nvmin 代表屏幕较短的一边，vmax 代表屏幕较长的一边"},{"title":"node初识","url":"/2019/08/13/node初识/","content":"\n\n\n# node\n\n1.安装\n\n2.执行\n\n\n\n# 1.读、写文件\n\n## 使用 `fs`模块\n\n```javascript\nfs.writeFile('./newfile.txt','大家好这是fs写的新文件',function(error){\n    console.log(error)\n});\n```\n\n\n\n# 2.开启一个简单的服务器\n\n## 1.使用模块`http`\n\n## 2.创建 server实例\n\n### `server.on` 接收请求，作出不同响应\n\n默认：`server.on(\"request\",function(req,res){})`\n\n细分：对请求的内容区分，相应不同内容。\n\n- 获取到 url地址`req.url`\n- 判断 `req.url` 内容返回不同的内容。\n\n### 2.1响应：`res.write(\"\")`\n\n- 响应write 可以由多个，但是必须要有end。有时候可以省略end，直接在end的时候放入内容。\n\n- 相应内容为中文的时候，需要设置响应头。\n\n  服务器默认发送的内容是 utf-8编码格式，但是浏览器不知道服务器使用的什么格式\n\n  `res.setHeader('Content-Type','text/plain;charset=utf-8')`\n\n### 2.2结束响应`res.end()`\n\n## 3.`server.listen` 绑定端口号\n\n```javascript\nserver.listen(3000,function(){\n    console.log(\"服务器已经开启了喵\")\n});\n```\n\n\n\n```javascript\nvar http = require('http')\n\n// 1.创建Server\nvar server = http.createServer()\n\n// 2.监听request请求事件，请求设置处理函数\nserver.on('request',function(req,res){\n    console.log('收到了请求',req)\n    res.write('hello world')\n    res.end() //以上可以直接 res.end('hello world)\n\t//获取到 请求路径的地址\n    var url = req.url\n\n})\n\n// 3.绑定端口号，默认是80，\nserver.listen(80,function(){\n    console.log('server is on ,you can use it!')\n})\n```\n\n<!--more-->\n\n# 根据路径不同区别页面输出\n\n重点在于判断 请求的路径 `req.url`\n\n```javascript\n\n    var url = req.url\n    if(url =='/'){\n        var obj = [\n            { id:1,name:'zss1',age:9},\n            { id:2,name:'zss2',age:9},\n            { id:3,name:'zss3',age:9},\n            { id:4,name:'zss4',age:9}\n        ]\n        // 返回的数据格式只能是：二进制数据或者字符串\n        // 数组-字符串： JSON.stringify\n        // \n        res.end(JSON.stringify(obj))\n    }else{\n        res.end('not found')\n    }\n})\n\n```\n\n![1565675474226](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1565675474226.png)\n\n\n\n\n\n解决中文乱码问题：\n\n`res.setHeader('Content-Type','text/plain;charset=utf-8')`即普通文本\n\n`res.setHeader('Content-Type','text/html;charset=utf-8')` html标签字符串。\n\n`res.setHeader('Content-Type','image/jpeg')` 设置图片显示\n\n# 返回数据渲染页面\n\n读取文本信息渲染页面\n\n```javascript\nvar fs = require('fs')\n\nvar server = http.createServer()\nserver.on('request',(req,res)=>{\n    // var url = req.url;\n    fs.readFile('./1.html',function(err,data){\n        if(err){\n            res.end('error')\n        }else{\n            res.setHeader('Content-Type','text/html;charset=utf-8')\n            res.end(data);\n        }\n    })\n})\n```\n\n1.html:\n\n```javascript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    \n    <h3 style=\"color:red\">haha</h3>\n</body>\n</html>\n```\n\n页面显示：\n\n![1565681200385](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1565681200385.png)\n\n# 使用模板引擎\n\n1.安装：`npm install art-template`\n\n2.加载：`var template = require('art-template')` \n\n3.模板结构置于html文件中\n\n4.渲染：\n\n- template(filename,data); //基于模板名渲染\n- template.compile(source,options);//将模板源代码编译成函数\n- template.render(source,data,options);//模板源代码编译成函数立即执行\n\n# export 和require\n\nrequire 可以加载 核心模块，第三方模块，自定义模块。当需要 加载多个js文件的时候，就需要用require 和export。\n\n- export 是导出文件变量，由require接收。\n\n- `export` 可以有多个，`export default` 仅有一个。通过`export`方式导出，在导入时加花括号，exprt default 则不需要\n\n\n\n# express\n\n原先http略有不足，无法满足需求，需要使用框架加快开发效率。\n\n## 定义\n\n- 基于 Node.js 封装的上层服务框架，它提供了更简洁的 API 更实用的新功能。\n\n- 它通过中间件和路由让程序的组织管理变的更加容易；它提供了丰富的 HTTP 工具；\n- 它让动态视图的渲染变的更加容易；它还定义了一组可拓展标准。\n\n## 使用\n\n- 安装（属于第三方插件\n\n  `npm install --save express`\n\n- 初始化\n\n  `npm init `\n\n- 引包\n\n  `var express = require('express');`\n\n- 创建实例\n\n  `var app = express();`\n\n- 监听：\n\n  `app.listen(3000,function(){}`\n\n  `);`\n\n```javascript\nvar express = require('express');\n\n// 1. 创建 app\nvar app = express();\n\n// 2.监听\napp.listen(3000,function(){\n    console.log('使用 express创建的 接口');\n});\n```\n\n拓展——：nodemon ,第三方命名航工具，`nodemon`来帮我们解决频繁修改代码重启服务器问题。\n\n是一个基于nodejs开发的一个第三方命令行工具。\n\n \n\n- 安装：`npm install --global nodemon`\n\n- 使用：`nodemon xxx.js`\n\n  ![1573919738305](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1573919738305.png)\n\n## 接口\n\n- send: 相比较于原始的 `res.write()` 和`res.end()` 搭配使用，`send`会自动完善 contenttype 部分。\n\n## 静态资源的区别开放\n\n1.`app.use('/static/image',express.static('./static/public'));`\n\n当以 `/static/image/` 开头的时候，去 `/static/image/` 目录下查找对应的资源。\n\n\n\n2.当省略 /static/ 第一个路径名，即客户端调用//image 的时候也会自动查找到 /static/image \n\n`app.use(express.static('./static/public'))`\n\n### 路由函数\n\n创建`router.js` 文件，内部放置所有的路径请求和响应。\n\n#### 请求方法不同\n\n- post    `app.get()`\n- get     `app.post()`\n\n\n\n## 在 express中使用 art-template\n\n安装\n\n`npm install --save art-template`\n\n`npm install --save express-art-template`\n\n配置\n\n`app.engine('art',require('express-art-template'))`\n\n当渲染使用 `.art`结尾的文件的时候，使用 art-template 模板引擎\n\n\n\n使用 \n\n创建 404.html 文件，再修改成 404.art\n\n`res.render('404.art')`\n\n\n\n但这样会出现 修改文件后缀名的情况，为了避免。可以直接在配置的时候 使用`app.engine('html',require('express-art-template'))`\n\n\n\n## 在表单中获取post 请求\n\nbody-parser\n\n没有内置获取post请求的 api\n\n安装：\n\n`npm install --save body-parser`\n\n引包：\n\n`var bodyParser = require('body-parser')`\n\n配置body-parser中间件\n\n`app.use(bodyParser.urlencoded({ extended: false}));`\n\n`app.use(bodyParser.json());`\n\n\n\n\n\n\n\n\n\n# crud-node-express\n\n1.页面引用了 bootstrap 模板，资源文件使用 npm 下载，并在app.js 中开放路径\n\n2.渲染 html 文件需要加载express-art-template文件，前者又 需要 art-template\n\n3.数据存放在本地json中，利用fs 读取，**因为在json中是字符串格式**，需要`JSON.parse()` 进行格式转换 才能用来渲染。\n\n4.制作 路由文件，接口比较多的情况下 将所有路由分离**出来成一个router.js文**件。代码比较简洁。 express 有单独的包装路由的api\n\n方法：\n\n```javascript\n// 1.引用\nvar express = require('express');\n// 2.创建路由容器\nvar router = express.Router();\n//3.把路由挂载到router路由容器中\nrouter.get('/',function(){});\n// 4.将router导出\nmodule.exports = router;\n\n\n\n在入口函数中将router挂载\nvar router = require('./router');\napp.use(router);\n```\n\n注意 挂在路由在 配置中间件之后。挂载需要时间\n\n\n\n路由设计\n\n| 请求方法 | 请求路径       | get参数 | post参数                 |                       |\n| -------- | -------------- | ------- | ------------------------ | --------------------- |\n| GET      | /students      |         |                          | 渲染页面              |\n| GET      | /students/new  |         |                          |                       |\n| POST     | /students      |         | name.age,gender,bobby    | 处理提交的新增数据    |\n| GET      | /students/edit | id      |                          | 改-找到对应的数据列表 |\n| POST     | /students/edit |         | id,name,age,gender.hobby | 改-提交修改的数据     |\n| GET      |                |         |                          |                       |\n|          |                |         |                          |                       |\n|          |                |         |                          |                       |\n\n# 链接到mongodb\n\n使用mongoose第三方进行mongodb数据，包括链接，数据操作以及其他\n\n1.导入\n\n`const mongoose = require(\"mongoose\")`\n\n2.链接到mongodb数据库\n\n`mongoose.connect(\"mongodb://localhost/自定义数据库名字\")` \n\n  2.1 如果需要连接到多个数据库。\n\n​\t`createConnection([uri],[options])`\n\n3. 断开连接\n\n`mongoose.disconnect()`\n\n\n\n\n\n\n\n## mongodb数据库安装\n\n1.安装。完成之后 会有这些执行文件\n\n![1575623320186](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1575623320186.png)\n\n2.配置环境变量，这样可以在任意路径下执行。\n\n![1575623437446](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1575623437446.png)\n\n把路径添加到 path变量中。\n\n3.可选择安装的 mongodb可视化工具。mongodb Compass Community\n\n![1575623543776](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1575623543776.png)\n\n\n\n\n\n## 操作数据库的api‘\n\n\n\n\n\n\n\n## 创建一条数据并保存到自己的数据库中\n\n1.创建数据模板。\n\n实际上这里定义的是collections中的document的结构，名为Schema。只需要指定字段名和类型及一些规则即可。\n\n`const Schema = mongoose.Schema()`\n\n```javascript\nconst UserSchema = new Schema({\n    title:{\n        type:String,\n        unique:true\n    },\n    author:{\n        type:String\n    },\n    price:{\n        type:Number\n    }\n})\n```\n\n如果需要在`Schema`定义后添加其他字段，可以使用`add()`方法\n\n```javascript\nUser.add({ name: 'string', color: 'string', age: 'number' });\n```\n\n\n\n\n\n2.发布模板\n\n```javascript\nvar MyModel = mongoose.model(单数大写字母, 创建的schema实例);\n// 以上为例。\nvar User = mongoose.model(\"User\",UserSchema);\n```\n\n\n\n\n\n3.以发布的模板为基础生成一条数据\n\n```javascript\nconst user1  = new User({\n    title:\"玫瑰红葡萄干\",\n    author:\"维利康食品有限公司\",\n    price:\"23\"\n});\n```\n\n\n\n4.保存该数据\n\n```javascript\nuser1.save();\n```\n\n"},{"title":"初识MongoDB","url":"/2019/07/25/初识MongoDB/","content":"\n\n\n\n\n数据库的必要：浏览器都是在内存中运行断电数据会丢失。\n\n- 一数据库的分类\n\n  - 关系型数据库\n    - MySQL、Oracle、DB2\n    - 数据库中都是表\n  - 非关系型数据库\n    - MongoDB、Redis\n    - 键值对数据库\n    - **文档数据库**MongoDB\n\n  <!--more-->\n\n- MongoDB\n\n  ![](https://i.loli.net/2019/07/26/5d3a5a257eba566659.png)\n\n  - 数据模型面向文档，是一种类似于JSOn的结构。\n  - 三个概念\n    - 数据库：数据库是一个仓库，在仓库中存放集合\n    - 集合：集合类似于数组，在集合中可以存放文档。\n    - 文档：文档数据中的最小单位，我们操作和存储的都是最小文档。\n\n- 启动数据库\n\n  - 1.安装\n\n  - 2.配置环境变量\n\n    将安装目录 配置到 path 中：\n\n    ```javascript\n    C:\\Program Files\\MongoDB\\Server\\3.4\\bin\n    ```\n\n    将这条地址增加到 path变量下\n\n  - 3.C盘新建 数据文件 data，data中再新建文件db\n\n    \n\n  - 4.命令行输入 `mongod` 启动（**启动服务器**）：用来保存数据\n\n  ![1564024593929](https://i.loli.net/2019/07/26/5d3a5a4bf001e43889.png)\n\n  - 显示 启动成功\n\n  - 5.再重新打开cmd 输入`mongo` （**启动客户端**）：用来操作数据\n\n    显示connecting：xxx，连接MongoDB成功。\n    \n    在 C盘data文件夹下的db文件中会生成一系列文件。\n\n  ![1564025630211](https://i.loli.net/2019/07/26/5d3a5a61d429e32361.png)\n\n\n\n​\t因为每次都要开启mongodb 的服务器和客户端，比较繁琐。\n\n​\t------将MongoDB设置为系统服务\n\n\n\n- 指令学习\n\n  - 前提知识：MongoDB 不需要提前创建数据库和集合，在创建文档的时候回一并创建。\n\n  - `db` 显示当前位置所在的数据库，类似于 this\n\n  - `use 数据库名` 进入到执行的数据库中（因为不需要提前创建数据库，所以即使进入一个新的数据库也不会报错，而是会显示`switch to db newdb` ，但是因为是新建的为空，所以在 `show dbs`的时候并不会显示该新建的）\n\n  - `show dbs` 即`show databases` 显示所有的数据库\n\n  - `show collections` 显示所有集合\n\n  - 数据库CRUD的操作\n\n    - 1.向数据库中插入文档：`db.集合名.insert(doc)`  其中 doc可以为一个对象；\n\n      ​\t**拓展：**\n\n      - 1.`db.collection.insertOne()` 插入一个文档\n      - 2.`db.collection.insertMany()` 插入**多个**文档\n\n    - 2.查询: \n\n      - 1.查询集合中所有的文档：`db.集合名.find()`  或者 `db.集合名.find({})`  \n      - 2.查询集合中符合条件的文档：`db.集合名.find({属性：值})`  找到属性和值都对应的文档 \n      - 3.获取该集合中所有文档的数量：`db.集合名.find({}).count()` \n\n    - 3.修改\n\n      - 完全修改`db.collection.update(\"查询条件\"：{xxx})`  **注意：这里的新对象是完全替换 查询条件查询出的 旧对象。**\n\n        `db.collection.update(\"查询条件\"：{xxx})` 是 更新1/更新多的 综合语句。默认情况下是更新1，当 将默认属性`multi` 改为`true`的时候，就会修改多个\n\n         `db.collection.update(\"查询条件\"：{xxx},{multi:true})`\n\n      - 部分修改，仅仅修改指定的属性：`db.collection.update(\"查询条件\"：{ $set:{ }})`  。在`$set:{}` 也可以通过增加新的属性来**新增该文档的新属性**;\n\n      - **同时修改多个**符合条件的文档：`db.collection.updateManay()` \n\n      - 修改一个符合条件的文档：`db.collection.updateOne()`\n\n      - 替换：`db.collection.replaceOne()`\n\n    - 4.删除\n\n      - 1.删除某个文档的指定属性：`db.collection.update(\"查询条件\"：{ $unset:{xxx }})`\n      - 2.删除文档\n        - `db.collection.remove(条件)` 默认删除一个；`db.collection.remove(条件，true)` 删除多个；`db.collection.remove({})` 传递一个空对象，会删除所有的文档（删除某集合：`db.集合名.drop()`）\n        - `db.collection.deleteOne()`\n        - `db.collection.deleteMany()`\n\n-  使用可视化工具：mongodbmanagefree\n\n  - 安装选择默认配置进入。如果数据库连接成功，会直接连接到localhost:27017接口\n\n    ![1564033826651](https://i.loli.net/2019/07/26/5d3a5a783dd8780573.png)\n\n\n\n- 在项目中使用MongoDB\n\n  - 原始的MongoDB 缺乏约束。\n\n  - Mongoose：\n\n    - 优点：\n      - 为文档创建一个模式结构\n      - 对模型中的对象/文档进行验证\n      - 可以使用中间件来与业务逻辑挂钩\n      - 比原生MongoDB更容易驱动\n    - 新的对象\n      - **Schema**（模式对象）：定义约束了数据库中的文档结构\n      - **Model**：作为集合中所有文档的表示，相当于MongoDB中的集合collection\n      - **Document**：表示集合中的具体文档，相当于集合中一个具体的文档。\n\n  - 使用\n\n    - 1.安装mongoose、nodemon（至于为啥在nodejs课程里面有讲到）\n\n    - 2.配置`scripts`\n\n      ` \"start\": \"nodemon ./bin/www\"`\n\n    - 3.执行：\n\n      `npm start`\n\n      **js代码部分**\n\n      ```javascript\n      var mongoose = require('mongoose');\n      mongoose.connect('mongodb://localhost/stus');\n      mongoose.connection.once(\"open\",function(){\n          console.log('1111111')\n      })\n      ```\n\n      控制台输出结果：\n\n      ```javascript\n      > @ start C:\\Users\\ASUS\\Desktop\\testmongoose\n      > nodemon ./bin/www\n      \n      [nodemon] 1.19.1\n      [nodemon] to restart at any time, enter `rs`\n      [nodemon] watching: *.*\n      [nodemon] starting `node ./bin/www index.js`\n      (node:1248) DeprecationWarning: current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.\n      1111111\n      ```\n\n\n\n\n\n\n\n- 生成文档\n\n  js代码\n\n  ```javascript\n  // 1.将 mongoose.Schema 赋值给一个变量 \n  var Schema = mongoose.Schema;\n  // 2.创建Schema（模式）的对象\n  var stuSchema = new Schema(({\n      // 定义文档中数据的类型\n      name:String,\n      age:Number,\n      address:String,\n      gender:{\n          // 设置默认值\n          type:String,\n          default:\"female\"\n      }\n  }));\n  // 3.创建Model ，Model代表着数据库中的集合，通过Model才能对数据库进行操作\n  // mongoose.model(modelName,schema)\n  // modelName 指的是映射的集合名\n  // StuModel 差不多是构造函数\n  var StuModel = mongoose.model(\"students\",stuSchema);\n  \n  // 4.创建文档,向数据库中插入\n  // StuModel.create(doc,function(err){});\n  StuModel.create({\n      name:\"孙悟空\",\n      age:90,\n      gender:\"male\",\n      address:\"花果山\"\n  },function(err){\n      if(!err){\n          console.log(\"插入成功\")\n      }\n  });\n  ```\n\n  控制台输出：\n\n  ![1564045639556](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\1564045639556.png)\n\n  manager工具打开可以显示所有的文档查看一下\n\n  ![1564045606722](https://i.loli.net/2019/07/26/5d3a5a918c5d347259.png)\n\n \n\n​\t说明 文档是 新建并且新增进数据库成功的"},{"title":"Swiper-移动端触摸滑动组件","url":"/2019/07/24/Swiper-移动端触摸滑动组件/","content":"\n# swiper使用注意事项\n\n\n\n\n\n\n\n\n\n\n\n# 在Vue中使用\n\n安装\n\n```ja\nnpm install --save swiper\n```\n\n使用\n\n​\t1.\n\n```ja\nimport \"swiper/dist/css/swiper.min.css\"\nimport \"swiper/dist/js/swiper.min.js\"\n```\n\n2.标签引入\n\n```javascript\n <div class=\"swiper-container\">\n     <div class=\"swiper-wrapper\">\n          <div class=\"swiper-slide\"></div>\n      \t  <div class=\"swiper-slide\"></div>\n     </div>\n     <!-- 分页器 -->\n \t <div class=\"swiper-pagination\">\n </div>\n```\n\n<!--more-->\n\n3.new swiper实例，绑定需要滑动的容器class名\n\n```javascript\nvar mySwiper = new Swiper(\".swiper-container\",{\n    loop: true,\n    pagination:{\n        el: '.swiper-pagination'\n    }\n });\n```\n\n\n\n","tags":["移动端组件"]},{"title":"vue中的slot插槽","url":"/2019/07/24/vue中的slot插槽/","content":"\n\n\n今天学习做外卖的时候学到一个新的知识点：插槽slot\n\nvue模板页面中的一个小知识点，但是看了觉得好神奇！\n\n情景：四个底部栏作为一级路由都会跳转到对于的页面，四个页面都具有顶部Top栏，但是Top栏中的组成和文字各不相同，仅仅样式一致。（组件大致相同，又有不同）\n\n<!--more-->\n\n![个人主页](https://i.loli.net/2019/07/24/5d37fc3652e8a92447.png)\n\n![订单列表](https://i.loli.net/2019/07/24/5d37fc5ca4d6131513.png)\n\n![home主页](https://i.loli.net/2019/07/24/5d37fc76bde7687937.png)\n\n![](https://i.loli.net/2019/07/24/5d37fc8d4457140363.png)\n\n1.常见HeadTop 顶部栏组件。在四个一级路由中只有Home主页的顶部栏左、右各有一个`span`放置着一个icon 和button，其他一级路由的顶部栏只有中间的title部分，且title文字不同。\n\n2.在 只有 Home主页具有的左右模块上 插槽 slot，因为有两个 ，使用name属性加以区分。\n\n```javascript\n<div>\n    <!-- 左边的插槽空位-->\n\t<slot name=\"left\"></slot>\n    <span> {{ title }}</span>\n   <!-- 右边的插槽空位-->\n    <slot name=\"right\"></slot>\n</div>\n```\n\n\n\n3.在使用组件的时候 ，中间文字利用父子组件传值 props 过去。\n\n4.而在Home主页中，因为一左一右，在使用组件的时候，直接将左边的icon 和右边的button 代码写入 在home组件中引用的HeadTop 组件中，如：\n\n```java\n <head-top :title=\"address\">\n   <!-- 左边的搜索 -->\n   <span slot=\"left\"> icon </span>\n\n   <!-- 右边的登录注册 -->\n   <span slot=\"right\"> button </span>\n</head-top>\n```\n\n并且 使用 `slot=\"name`值\"加以区分 不同的插槽。\n\n\n\nprops传递数据，slot传递标签\n\n注意：\n\n- 1.在插槽标签中`<slot></slot>` 放置标签元素，属于默认配置。即使用该插槽的组件未给插槽传入任何值，\n\n插槽标签中`<slot></slot>`  中的元素会默认显示\n\n- 2.","tags":["slot"]},{"title":"阮雪峰git-学习笔记","url":"/2019/07/23/阮雪峰git-学习笔记/","content":"\ngit保存路径：\n\n本地文件夹/工作区域 ——暂存区域——git仓库\n\n   1.git add 新增和修改都是使用add添加至暂存区域；\n\n2. git diff 查看修改内容\n\n3. git log 查看每次提交的信息和修改内容，即版本信息\n\n<!--more-->\n\n#   版本回退\n\n​    1.HEAD 表示当前版本。上一个版本是 HEAD^  上上一个版本是 HEAD^^ ,简化写成HEAD~2；\n\n2. `$ git reset --hard HEAD^`  表示回退到上一个版本，本地文件就会被回退成上一次修改之前的版本。\n\n​    当回退到旧版本时，重新 git status 的时候，就不会再显示回退之前的新的版本。\n\n​    可以强制：\n\n​    3.`$ git reset --hard '需要回退的版本号'`【每次commit都会产生一个commit id，为十六进制的数】\n\n​    版本号不需要写全，4-5位即可，譬如：1094a\n\n​    `$ git reflog` 显示每一次的命令语句\n\n​    <u>大佬的总结：</u>\n\n- HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id。`\n- 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。\n- 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本\n\n\n\n# 添加文件：\n\n​    **git add 和 git commit**\n\n​    `git add`：文件修改添加到暂存区\n\n​    `git commit`：暂存区的所有内容提交到当前分支\n\n​    $ git checkout -- filename（注意空格）撤销工作区修改\n\n​    $ git reset HEAD filename 可以把暂存区的修改撤销掉（unstage），重新放回工作区：\n\n\n\n​    大佬小结\n\n-  场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令`git checkout -- file。`\n- 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令`git reset HEAD filename`，就回到了场景1，第二步按场景1操作。\n- 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。\n\n\n\n​    2.误删了工作区的且已经commit的文件需要恢复（仅有commit 的文件误删才能被恢复）：`$ git checkout -- filename`\n\n# 删除文件\n\n1. 当本地删除文件之后。工作区和版本库的就不一致了，`git status` 就会提示 `Changes not staged for commit(未准备提交的更改)`\n\n 那么有两个选择： \n\n​\t①  从版本库中删除。`git rm` 并 `git commit` ，即工作区和版本库一致。\n\n​\t② 是手滑删错了，想让工作区和版本库一致 `$ git checkout -- test.txt` 即可 恢复工作区版本。\n\nTip： `git checkout`其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。但是：**从来没有被添加到版本库就被删除的文件，是无法恢复的！**\n\n\n\n# 连接远程仓库\n\n(前提：创建自己的github 账户，配置SSH公钥。同一个github 可以配置多个公钥，就可以是实现同一个用户异地多台电脑上传，也是 推送到远程仓库的密码)\n\n1.关联语句执行\n\n```javascript\n$ git remote add origin git@github.com:zyw1988/TodoList.git\n// git@github.com:zyw1988/TodoList.git 是你创建的某仓库地址，TodoList是仓库名\n```\n\n2.推送\n\n`git push `\n\n`git push -u origin master ` 如果是第一次推送，远程仓库是空的，使用 `-u` 在之后的推送就可以直接使用 `git push origin master` 代替`git push -u origin master`\n\n\n\n# 从远程库克隆\n\n1.克隆语句执行\n\n`git clone 地址` \n\n\n\n","tags":["git","笔记"]},{"title":"图片md示例","url":"/2019/07/23/3.图片md示例/","content":"\n![运动函数](https://i.loli.net/2019/07/23/5d366da8ea8fc53681.png)"},{"title":"我的VUE初识","url":"/2019/07/22/我的VUE初识/","content":"\n如果说 jq是简化了对DOM 的操作，那么vue就是完全解放了双手（也不，底层DOM vue中也是可以获取到并操作的）\n\n  \n\n# Vue实例\n\n当需要把一个页面使用Vue框架搭建的时候，需要创建VUE实例\n\n```javascript\nvar vm = new Vue({\n    el:\"#app\"\n})\n```\n\n其中，el 是指代需要VUE搭建的区域id\n\n<!--more-->\n\n## 1.data：\n\n当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时 data 中存在的属性才是响应式的\n\n- 模板语法：data中的变量通过花括号文本插值\n\n## 2.指令：\n\n当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。\n\n### 1双向绑定：v-model\n\n`v-model=\"data1\"` 。一般用于input、textarea、select、checkbox、radio等表单元素。注明 初始值。\n\n动态属性赋值：`v-bind:xxx=\"data1\"`  简写：`:xxx=\"data1\"`\n\n#### 1、style 的动态绑定：\n\n- `:style=\"{color:ActiveColor,fontSize:fontsize+'px'}\"`\n\n- 布尔值判定：`:style=\"{ color:isFlag?\"#000\":\"#fff\" }\"`\n\n- 需要拼接单位的`:style=\"{width:width+'px',height:height+'px'}\"`\n\n  \n\n#### 2、 class动态绑定 \n\n在项目中`class` 属性经常会被修改，会使用动态绑定一个变量的方法来控制class\n\n-  1.绑定单个变量\n\n  `:class=\"className\"` 如果是 `:class=\"'RedColor'\"` 内部用单引号`''`包裹是引用的常量`RedColor`\n\n- 2.绑定多个 class变量\n\n  `:class=\"['classA','classB']\"`\n\n- 3.通过布尔值控制class类名的绑定：\n\n  - ① 与变量判断是否相等\n\n    `:class=\"{classA:isChoose==\"xxx\"}\"`\n\n    多个：逗号隔开\n\n    `:class=\"{'full':item.name=='满减','first':item.name=='首单','special':item.name=='特价'}\"`\n  \n  - ②直接布尔值控制\n\n    `:class=\"{ classA:isA,classB:isB}\"`\n  \n  - ③和三目运算符一起使用\n  \n    ```javascript\n  :class=\"{ x>y?'classA':'classB'}\"\n    ```\n  \n    \n\n### 2事件绑定：v-on\n\n`v-on:click=\"clickEvent\"` 简写：`@click=\"ckickEvent\"`\n\n列表渲染：`v-for=\"item in lists\"`。vue2之后需要在v-for之后动态绑定上id`:key=\"item.id\"` 。这里的lists 可以是一个对象，数组或者是 常量\n\n通过 `v-for` 循环得到的组件，如果要加 过度动画`transition` 应该使用标签`<transition-group>`\n\n```javascript\n<li v-for=\"item in 5\">{{ item }}</li>\n输出：\n·1\n·2\n·3\n·4\n·5\n```\n\n#### 修饰符\n\n- 1.`.lazy`不会在input时更新，而是在change时更新\n- 2.`.trim`自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：\n- 3.`.number`自动将用户的输入值转为数值类型\n- 4.`.stop`停止事件冒泡\n- 5.`.prevent`阻止默认行为 a的自动跳转\n- 6.`.enter` `.esc` 或者`.13` 指代特定的键盘事件 ，跟在`keyup（keydown）`之后\n\n## 3.methods：\n\n操作数据修改dom的方法对象\n\n(待补充)\n\n## 4.computed：\n\n计算属性。实际也是方法，但是计算属性的调用和属性类似。\n\n应用场景：当需要 对数据进行处理 且多次使用的时候（有待深入）\n\n1.有get 和set 两个方法。默认是调用get方法。get只读属性，set 是设置\n\n```javascript\n fullname:{\n     set:function(){},\n     get:function(){}\n}  \n```\n\n默认是 调用get方法，所以可以简略写成\n\n```javascript\nfullname:function(){...}\n```\n\n2.set方法是设置值的，所以 在set方法中可以通过形参获取到 需要被赋值的数据\n\n```javascript\nfullname:{\n     set:function(newVul){\n         console.log('新的值',newVul)\n     },\n     get:function(){}\n}  \n```\n\n\n\n## 5.watch：\n\n侦听属性，侦听某个变量的改变，以该变量名为函数名，创建函数。\n\n```javascript\n....\ndata:{ msg:\"\"},\nwatch:{\n    msg:function(){\n        console.log('msg发生了改变')\n    }\n}\n```\n\n（有待深入，watch的变量只能是data中定义的么，定义任何类型的数值都是一样的吗？）\n\n## 6.filter过滤器：\n\n注册：\n\n```java\nVue.filter('msgFilter',function(msg){\n    // Vue.filter('过滤器名称',函数)\n    return msg.replace('a','ccc')\n})\n```\n\n使用：\n\n```javascript\n<span>{{ item|msgFilter}}</span>\n```\n\n## 7.自定义指令\n\n(待完善)\n\n```javascript\nVue.redirect()\n```\n\n\n\n## 8.过渡和动画\n\n- 定义和区别：之前的过渡是在CSS中使用属性`transition` 给元素设置过渡的要素。在Vue中需要使用 标签形式的`transition` 将需要过渡的元素包裹。\n\n- 包含进入和离开两场动画，分别是enter进入有 `v-enter` `v-enter-to`   离开leave 有`v-leave` `v-leave-to`  。\n\n  ![](https://i.loli.net/2019/07/27/5d3c52367baa820837.png)\n\n- 使用：\n\n  - 1.将需要过渡的组件用标签形式的transition包裹 `<transition> ... </transiton>`\n  - 2.从过渡的变化过程可以看到，`v-enter` 和`v-leave-to` 的效果是一样的，而`v-enter-to`和`v-leave`是一样的。所以①在CSS中 定义 `v-enter`和 `v-enter-to` 的动画效果即可。②通过`v-enter-active` 和`v-leave-active` 定义整场动画的时间\n\n- 半场动画（**案例：加入购物车小球的下落动画**）\n\n  是一个只需要进入，不需要离开的动画效果，使用钩子函数控制\n\n  ```javascript\n  <transition\n      @before-enter=\"handleBeforeEnter\"\n      @enter=\"handleEnter\"\n      @after-enter=\"handleAfterEnter\">\n  \t<div class=\"ball\" v-if=\"isflag\"></div>    \n  </transition>\n  ```\n\n  操作函数部分：\n\n  ```javascript\n   beforeEnter:function (el) {\n        el.style.transform=\"translate(0,0)\";\n          },\n          \n   enter:function (el,done) {\n         el.offsetWidth\n  \n         // 获取小球 的距离.因为各种设备的大小不同，固定数值会出现差错。所以从位移差入手。\n         const ballPosition = this.$refs.ball.getBoundingClientRect();\n         const badgePosition = document.getElementById('mui-badge').getBoundingClientRect();\n         const xDist = badgePosition.left - ballPosition.left ;\n  \tconst yDist =  badgePosition.top - ballPosition.top;\n              \n  \t// 将 距离差 字符串拼接进 \n  \tel.style.transform=`translate(${xDist}px,${yDist}px)`;\n  \tel.style.transition=\"all 1s linear\"\n  \t// 跟老师不一样的地方。\n  \tel.addEventListener('transitionend',done)\n          },\n  afterEnter:function (el) {\n          this.flage=!this.flage;\n          },\n  ```\n\n  \n\n## render渲染组件\n\n使用render 渲染会完全替换掉`#app div`，不会导致页面出现div嵌套div 的情况\n\n# 二、组件化\n\n## 1.组件的定义和使用\n\n​\t可以多次复用；减少耦合；是特殊的vue实例，有自己的data和methods和computed以及生命周期钩子函数。其中 【data】必须是一个函数，且返回一个对象。\n\n- 组件的三种声明方式\n\n  1.`Vue.extend`\n\n  ```javascript\n  //定义模板字符串\n  var com1 = Vue.extend({\n      template:'<h2>我是extend 创建的组件</h2>'\n  })\n  //利用模板字符串注册组件\n  Vue.components('myCom1',com1)\n  //在html中标签形式引入\n  <my-com1></my-com1>\n  \n  ```\n\n  2.方法1 的简化\n\n  ```javascript\n  Vue.components('myCom1',{\n      template:'<h2>我是extend 创建的组件</h2>'\n  })\n  ```\n\n  3.模板文件id的引入\n\n  ```javascript\n  <template id=\"temp\">\n      <p> 略略略 </p>\n  </template>\n  \n  //Vue部分\n  Vue.component('myCom1','#temp')\n  ```\n\n  4.单文件.vue的使用（.vue文件需要配套webpack 编译打包）\n  \n  ```javascript\n  <!--  App.vue文件-->\n  <template>\n      <div>\n      \t//div作为根标签，有且只能一个\n      \t...\n      </div>\n  </template>\n  ```\n\n\n\n\n  ​\t\t\t注意，组件模板中必然只能只有一个根标签，即template内部必须要一个根标签包裹所有的子孙标签\n\n## 2.组件之间的传值\n\n- ##### 1.父子组件之间传值\n\n  - 1.`props` 和`$emit` \n\n    **父——子：**\n\n    动态属性绑定需要传递给子组件的值`:father=\"son\"`，子组件通过props 接收`props:[\"son\"]`\n\n    **子——父：**\n\n    原理是 子组件无法直接修改由 父组件传递过来的值，需要将修改的变量再回传递给父组件，由父组件事件修改。\n\n    1.在子组件中注册事件 2，在该事件处理中通过 `this.$emit(fn,obj)`将变量内容obj 传递给fn函数。3.在父组件对应该子组件的标签中绑定事件`@ffn=fn` 4.在父组件的ffn事件中获取到obj变量，对数据进行操作。\n    \n    父：\n    \n    ```javascript\n    <mt-button @fnn=\"fn\"><mt-button>\n    ```\n    \n    子\n    \n    ```javascript\n    <!-- mtButton组件-->\n    <template>\n        <div>\n        \t<i class=\"iconfont sousuo\"></i>\n    \t\t<button @click=\"clickEvent\">button<button>\n        </div>\n    </template>\n        \n     <script>\n        export default{\n    \t\tdata(){\n                return {}\n            },\n            methods:{\n                 clickEvent(){\n                     this.$emit(fn)\n                 }\n             }\n    }\n     </script>\n    ```\n    \n    \n    \n  - 2.`$children`/`$refs` 和`$parent` \n  \n    访问子组件的应急方法，用于直接获取子组件的data数据和methods方法。\n  \n    `this.$children` 是一个数组类型，包含所有的子组件对象\n  \n    \n  \n  - `Provide`和`reject` \n  \n    允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。\n  \n    **缺点：**一对多必然导致多个组件使用同一个数据的时候导致追踪使用情况困难。\n  \n    - 使用步骤\n  \n      1.父级通过privode提供变量，该`privode` 是一个对象 或者是返回对象的函数。\n  \n      ```javascript\n      provide:{\n          'msg':\"I am Dadd\"\n      }\n      ```\n  \n      2.子组件或者孙子组件通过inject获取，`inject`是一个字符串数组或者一个对象，对象中包含from和default默认值。from属性是provide里对应的对象名，default属性是不存在时的默认值\n  \n      ```javascript\n      //数组，变量名为 父级中声明的变量名\n      inject:[\"msg\"];\n      //对象，key为本组件中变量名，value 是provide中对应的对象名，也可以是一个对象，\n      inject：{\n          \"sonMsg\":'msg'\n      }\n      // value为一个对象\n      inject:{\n          \"sonmsg\":{\n              from:'msg'\n              default:'I am son1'\n          }\n      }\n      ```\n  \n      子组件在接收到provide的数据之后，在data中注册之后再能使用\n  \n      ```javascript\n      data(){\n          return {\n              Sonmsg:this.msg\n          }\n      },\n      inject:{\n           \"sonmsg\":{\n              from:'msg'\n              default:'I am son1'\n          }\n      }\n      ```\n  \n      \n  \n  - Vuex：集成式状态管理，始用于大型开发，另开一题详解，\n\n# 三、路由\n\n## 1.路由的定义和使用\n\n控制页面的跳转\n\n1。安装：`npm install vue-router`\n\n2。生成VueRouter 实例并定义路径规则：`var router = new VueRouter({routes:[{...},{...},{...}]})` \n\n3。挂靠到Vue实例上：\n\n```javascript\nvar vm = new Vue({\n    el:\"#app\",\n    router\n})\n```\n\n4。在html页面中 放置 路由链接和路由显示的界面\n\n```javascript\n  <router-link to=\"/login\"></router-link>\n  <router-link to=\"/register\"></router-link>\n\n  <router-view ></router-view>\n```\n\n5.为路由设置默认显示，即当 '/' 默认页面显示的路由组件内容.\n\n即将 \"/\"的地址通过redirect 重定向到 “/Login” 这个页面\n\n```javascript\nvar router = new VueRouter({\n    routes:[\n        { path:\"/\",redirect:\"/login\"},\n        { path:\"/login\",component:\"Login\"}\n    ]\n})\n```\n\n如果是使用规则定义的方法：\n\n```javascript\n { path:\"/\",component:\"/login\"}\n```\n\n会导致hash 混乱（具体咋混乱咱也不知道）\n\n6。路由链接本质是 a标签，被点击会有 active 样式，可以在CSS中手动设置，路由VueRouter 也提供 `linkActiveClass` 为路由增加被点击的样式：\n\n```javascript\nvar router = new VueRouter({\n    routes:[\n        { path:\"/\",redirect:\"/login\"},\n        { path:\"/login\",component:\"Login\"}\n    ],\n    linkActiveClass:\"active\"\n})\n```\n\n\"active\" 为CSS中手动设置的样式\n\n## 2.路由的传值\n\n- 主要分两种，params 和query。\n\n- 路由的 to属性一半默认写法都是字符串形式`<router-link to=\"/home\"></router-link>` ，但其实也可以用过 对象传值的方式，只需要将to属性动态绑定：`<router-link :to=\"{path:'/home'}\"></router-link>`。 这样的话如果要传值就可以：\n\n  ```javascript\n//使用 query\n  <router-link :to=\"{path:'/home',query:{ key: value }}\"></router-link>\n  ```\n  \n  \n  \n- **query**，查询字符串传值：`\"/login?id=10\"` 类似于get传值，通过`？`传递参数，不需要额外配置路由格式。\n\n  ```javascript\n  //1. 普通传值 ？拼接\n  <router-link to=\"/login?id=1065889489> 进入login 组件</router-link>\n  //1.1 普通传值 对象形式\n  <router-link :to=\"{path:'/home',query:{id:1065889489}}\"></router-link>\n  \n  // 2.动态传值，用在v-for循环中，将每个item 的id 传给to后的值\n  <router-link  :to=\"{path:'/shop/'+item.id }\" v-for=\"item in obj\"> 进入login 组件</router-link>\n  ```\n\n  通过`this.$route.query` 获取到`?`后跟随的数据\n\n  ```javascript\n  控制台输出this.$route 会显示：\n  {\n      ...\n      fullPath:\"/login/1065889489\",\n      hash:\"\",\n      params:{},\n      path:\"/login\",\n      query:{id:1065889489},\n      __proto__:Object\n  }\n  ```\n\n  `query` 会输出一个对象\n\n- **params**  通过`/`传值，需要修改路由中的路径规则，配置路由格式：\n\n  ```javascript\n  { path:'/login/:id/:name',component:Login}\n  ```\n\n  当点击路由跳转的时候，网页地址就会变成  xxxxx/login/10/zyw\n\n  ```javascript\n  <router-link to=\"/login/10/zyw\"> 进入login 组件</router-link>\n  //动态赋值\n  <router-link :to=\"{path:'/shopsinfo/'+item.id }\"> 进入login </router-link>\n  ```\n\n  通过`this.$route.params` 获取，`params` 获取到的是一个对象形式数据\n\n## 3.路由变量\n\n- 1.`this.$route`（有待完善）\n\n   是**当前活跃的路由对象**，可以获取当前路由的路径query、params、meta等参数\n\n- 2.`this.$router` \n\n  是**VueRouter的一个实例对象**，包含history对象，使用`this.$router.push()` 可以进行路由页面跳转；`this.$router.go(-1)` 返回上一个页面;`this.$router.replace('/login')` push是可以返回上一个的，replace是不可以返回的\n\n## 4.多级路由定义和使用\n\n实现多级组件嵌套的效果\n\n- 1.在需要嵌套多级子路由的路径下，增加属性：`children` ，为一个数组格式。在其中增加子路由的路径规则：`{path:\"/son1\",component:Son}` 。因为是设置在当前路径之下的子路由路径，所以 不用加上当前的路由路径。\n\n  ```javascript\n  { path:\"login/son1\",component:Son };// 错误，默认就是 /logn 之下的路径\n  { path:\"/son1\",component:Son }；//正确\n  ```\n\n- 2.在增加了路径之后，同样需要 增加路由标签和划定区域\n\n  ```javascript\n  <router-link to=\"/login/son1> 进入son1 子组件</router-link>\n  <router-link to=\"/login/son2> 进入son2 子组件</router-link>\n  <router-view></router-view>\n  ```\n\n  注意：在子路由标签中的`to=\"\"` 之后是需要加上 父级路由的路径的。\n\n## 5.命名视图\n\n功能分析：路由由 router-view展示，当在地址不变的情况下，同时展示 三个及以上路由，这就需要用到 命名视图\n\n## 6.编程式导航\n\n导航一般是通过路由的to跳转，在这里介绍导航的另一种方式：编程式导航。\n\n要点：利用`click`点击事件 +   `this.$router.push()`方法。\n\n1.直接跳转\n\n`this.$router.push(‘/home/goodsinfo”);`\n\n2.`/`传递参数的方法\n\n`this.$router.push(“/home/goodsinfo/”+id );`\n\n3.传递对象的方法\n\n```javascript\nthis.$router.push({ \n\tName :\"goodsinfo\",\n\tParams : { id:id_x }\n}); \n```\n\n4.`replace` 也是直接跳转，与`push` 的区别在于，`push` 过去的网址还能返回到前一个，而`replace` 是无法返回。\n\n`this.$router.replace(\"/home\");`\n\n- 7.路由懒加载：在一个页面呈现的时候，不需要让所有的路由接口都加载，只有点击的时候再去加载，能促进高校\n\n   ​\t使用方式\n\n   ```javascript\n   const Home = ()=>import('../../components/Home.vue')\n   //也可以直接在 路由规则中写入\n   const router = new VurRouter({\n       routers:[\n           { path:\"/home\",component:import('../../components/Home.vue'}\n       ]\n   })\n   ```\n\n\n## 7.路由中其他的一些功能：\n\n1.打开页面默认显示 某个子组件：在一级路由规则中 另外定义 redirect\n\n2.在Vue中使用DOM元素\n\n- 1.为标签元素增加属性`ref=\"xxx\"` ，通过`this.$refs.xxx` 能获取到DOM元素。该方法也能用于组件，获取到组件的data 和methods\n- 2.在methods中定义的方法，如果使用的时候未传参，那么在申明的时候的形参ele即指代执行函数的底层DOM，未传参时候的默认参数\n\n# 四、生命周期钩子函数\n\n![](https://i.loli.net/2019/07/29/5d3e6a6d55a7d34457.png)\n\n- ### Vue脚手架（webpack手动配置的基础上）\n\n# 五、Vuex\n\n- 定义：\n\n![](https://i.loli.net/2019/07/29/5d3eaeed4dddb57354.png)\n\n\n\n- State:状态，可以简单理解为data\n- View：视图层\n- Actions：用户的各种操作，\n\n  作为插件，在安装、导入之后，需要`Vue.use(Vuex)`\n  \n- 核心概念：\n\n  - state：\n\n    单一状态树：\n\n  - mutation：跟踪同步的操作，内部方法默认形参state。是Vuex的store状态的更新唯一方法。\n\n    - Mutation主要包括两部分：\n\n    ​\t\t1.字符串的事件类型：type\n\n    ​\t\t2.回调函数（handler），该回调函数的第一个参数就时 state\n\n    - mutation的定义方式\n\n      ```javascript\n      mutations:{\n          increment(state){\n             \t...\n          }\n      }\n      //外部传参形式\n      increment(state,count){\n             \t...\n      }              \n      ```\n\n      \n\n    - 通过mutation更新\n\n      ```javascript\n      increment:function(){\n          this.$store.commit('increment')\n      }\n      //外部传参形式\n      increment:function(newVul){\n          //注意，这里的newVul 包括了type和newVul，会自发形成一个对象传过去，所以传过去使用外部参数的时候需要通过对象的形式 获取一下\n          this.$store.commit('increment',newVul)\n      }\n      //特殊的传参方式\n      increment:function(newVul){\n          this.$store.commit({\n              type:'increment',\n              newVul:newVul\n          })\n      }\n      ```\n\n      \n\n  - actions：异步操作，譬：网络请求，在actions中定义了异步操作再在mutation中修改状态\n\n  - getters：数据的变换操作，简单理解为computed\n\n    在getters中的方法默认带参数`state` ，如果另外传入 形参`getters` 能获取到所有的getters方法。且所有方法最多只能有两个参数，即state 和getters。\n\n    ```javascript\n    state:{\n        students:[\n            { id:1,name:'zs1',age:90},\n            { id:2,name:'zs2',age:19},\n            { id:3,name:'zs3',age:9}\n        ]\n    },\n    getters:{\n        msgFilter(state){\n            return state.students.filter(item=>item.age>20)\n        },\n        msgFIlterLength(state,getters){\n            return getters.msgFilter.length\n        }\n    }\n    //通过 形参getters 能获取到所有的getters 方法，对于计算步骤一致的方法就能通过 getters.xx的方式调用而避免重复代码\n    ```\n\n    如果在调用getters中的方法时想要额外传入外部参数。则要求 getters的方法返回一个函数，\n\n    ```javascript\n    //功能实现，输出 大于外部参数age 的students\n    getters:{\n        getAge(state){\n            return function(age){\n                return state.student.filter(s=>s.age>age)\n            }\n        }\n    }\n    // 形参age为 外部调用传入的数据\n    ```\n\n    \n\n  - module：按模块划分数据\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["VUE","初级"]},{"title":"如何使用hexo美化自己的个人博客","url":"/2019/07/22/2.如何使用hexo美化自己的个人博客/","content":"\n# 1.介绍及用途\n\n- 基于 node.js 制作的一个博客工具\n- 不需要部署到服务器，在服务器上保存的其实是 基于在hexo上编写的md文章。hexo帮我们生成静态的html页面，再将html上传到我们的服务器\n- 会用到 git命令语句\n\n<!--more-->\n\n# 2.安装和初始化\n\n- 1.安装hexo ：`npm install hexo-cli -g `  \n\n- 2.初始化：`hexo init` 之后会生成一系列文件夹\n\n- 3.`npm install` 安装依赖包\n\n- 生成文件夹预览以及含义：\n\n  - ```\n    `.├── _config.yml  ：网站的 配置 信息，您可以在此配置大部分的参数\n      ├── package.json\n      ├── scaffolds  ：模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。\n      ├── source ：资源文件夹是存放用户资源的地方。\n      |  ├── _drafts\n      |  └── _posts ：编写的md文件存放地址\n      └── themes：主题 文件夹。Hexo 会根据主题来生成静态页面。\n      ` \n    ```\n\n- 与自己的github个人主页绑定（默认已经有自己的github主页）\n\n  ```javascript\n  deploy:\n    type: git\n    repository: git@github.com:xxx/xxx.github.io.git\n    branch: master\n    \n  \n  ```\n  \n  注意：键值对中间要有空格，不然会报错。与此同时也要修改url处为自己的github个人主页地址\n  \n- 初始化github绑定\n\n  - 1.安装  hexo-deployer-git `$ npm install hexo-deployer-git --save` \n  - 2.`hexo d`部署到github 上\n\n# 3.常用语句\n\n- 下载主题\n\n  ```javascript\n  $ git clone 主题地址\n  ```\n\n- `$ hexo init [folder]` :新建一个网站。如果没有设置 `folder` ，Hexo 默认在目前的文件夹建立网站。\n\n- 设置主题即个人特色标题和其他：\n\n  - 1.所有的信息都在 根目录下的`_config.yml` 中 修改`\n  - 2.`theme`字段为 你克隆下来得主题名称。\n  - 3.`title`：网站标题\n  - 4.`subtitle`：网站副标题\n  - 5.`description` ：网站描述，用于SEO\n  - 6.`author`：博主的名字\n  - 7.`avator`:侧边栏头像设置\n\n- `hexo clean` ：清除缓存 文件（db.json)和已生成 的静态文件（public）\n\n- `hexo g && hexo s` 生成静态文件并且启动服务器预览，是`hexo deploy`和 `hexo server`的简写\n\n- `hexo  new \"笔记标题\"`  新建笔记，报错使用 `hexo new '[post]' \"标题\"` \n\n- `hexo d`部署之前预先 生成的静态文件，是`hexo generate` 的简写\n\n- ","tags":["github个人主页搭建","hexo"]},{"title":"我的js 复习笔记","url":"/2019/07/19/1.js复习笔记/","content":"\n\n\n\n## 一、JS数据格式分类\n\n- （一）JS中有5（6）种基本数据格式和1中引用类型，分别是 null，undefined，number，string，boolean，（ES6新增symbal），引用类型：Object、Array、Function、Date等\n\n  <!--more-->\n\n- （二）通过typeOf会显示的数据类型：\n\n  |            | 显示                                                         |\n  | ---------- | ------------------------------------------------------------ |\n  | null       | Object（null类型被当做一个空对象引用）                       |\n  | {}         | ↑                                                            |\n  | []         | ↑                                                            |\n  | 123        | Number                                                       |\n  | NaN        | Number（注意：①任何有关NaN的计算都不等于NaN②NaN不等于任何值，包括自己） |\n  | ’string‘   | string                                                       |\n  | true/false | boolean                                                      |\n  | undefined  | undefined                                                    |\n  |            |                                                              |\n\n- （三）通过instanceOff 会显示的数据类型\n\n\n\n## 二、数组方法\n\n|                                                              | 解释                                                         | 返回值                                                       | 原数组是否被修改                             |\n| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------- |\n| join(separator)                                              | 将数组的元素组成一个字符串以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符 | 拼接过的字符串                                               | 否                                           |\n| push()                                                       | 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。 | 更新之后的长度                                               | 是                                           |\n| pop()                                                        | 移除数组末尾最后一项，减少数组的 length 值，然后返回移除的项 | 被删掉的数组                                                 | 是                                           |\n| shift()                                                      | 删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。 无参。 | 被删掉的数组                                                 | 是                                           |\n| unshift()                                                    | 将参数添加到原数组开头，并返回数组的长度 。                  | 更新之后的长度                                               | 是                                           |\n| sort()                                                       | 按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。传入的参数是两个，return的是二者的差值，如果>1则升序![img](file:///C:\\Users\\ASUS\\AppData\\Local\\Temp\\ksohtml13596\\wps1.jpg) | 更新之后的数组                                               | 是                                           |\n| reverse()                                                    | 反转数组项的顺序。                                           | 新数组                                                       | 是                                           |\n| concat()                                                     | 用于连接两个或多个数组。将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在无参数的情况下，它只是复制当前数组并返回副本。 | 返回新数组                                                   | 否                                           |\n| slice(startIndex,endIndex)                                   | 字符串也有这个方法返回从原数组中指定开始下标到结束下标之间的项组成的新数组。会有两个参数，如果第二个参数没有则默认一直到数组最后。相当于截了一段原数组中的一段。![img](file:///C:\\Users\\ASUS\\AppData\\Local\\Temp\\ksohtml13596\\wps2.jpg) | 被‘剪’出来的数组                                             | 否                                           |\n| splice(startIndex,deleteNum,new1,new2)                       | 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。![img](file:///C:\\Users\\ASUS\\AppData\\Local\\Temp\\ksohtml13596\\wps3.jpg) | 如果删除，会返回被删除的数组。如果不是删除，则返回一个空数组[] | 删除：改变原数组插入：无返回值，原数组被改变 |\n| indexOflastIndexOf                                           | 字符串也有这个方法。可返回某个指定的字符串值在字符串中首次出现的位置。不存在返回-1，存在位置索引。 |                                                              |                                              |\n| forEach(f)                                                   | 循环操作，参数是function                                     | 无返回值                                                     |                                              |\n| map()                                                        | 指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的**数组。** | 调用结果组成的数组                                           | 是                                           |\n| filter()                                                     | “过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。 | 数组                                                         | 不改变原数组                                 |\n| Every()                                                      | 判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。 |                                                              |                                              |\n| some()                                                       | 判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。 |                                                              |                                              |\n| reduce(function(prev, cur, index, array),初始值)reduceRigth() | 都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。 |                                                              |                                              |\n| findIndex(func())                                            | 找到索引                                                     | 索引值                                                       |                                              |\n\n## 三、字符串方法\n\n|                        | 解释                                                         | 返回值                                                       |\n| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| indexOf()              | 返回子字符串第一次出现的位置，从startIndex开始查找，找不到时返回-1 | 目标字符串第一次出现的位置，或者 -1                          |\n| lastIndexOf()          | 从最后往前找子字符串，找不到时返回-1（与 indexOf的区别就是开始的方向不同） |                                                              |\n| match()                | 正则匹配                                                     |                                                              |\n| charAt(index)          | 取出单独的字符串，index为字符串下标                          | 子字符串                                                     |\n| charCodeAt(index)      | 返回子字符串的unicode编码，                                  | 子字符串的编码值                                             |\n| substring(start,end)   | 截取字符串，从start开始，截取end位                           | 子字符串                                                     |\n| slice(start,end)       | 遇上相同                                                     | 子字符串                                                     |\n| split(separator,limit) | 以separator为查找目标字符串，并以此为分隔符，分割开原始字符串**形成数组**。limit是返回的字符串个数，如果不设置则以最大的个数显示。separator设置为””，则以逗号隔开；如果separator不设置，则返回原数组。![img](file:///C:\\Users\\ASUS\\AppData\\Local\\Temp\\ksohtml13596\\wps4.jpg) | 数组                                                         |\n| replace                | 替换字符串。如果找不到目标元素则返回源字符串；并且是找到第一个目标元素就停止 | 返回替换之后的数组。原数组不变。                             |\n| inclueds               | 表示是否找到目标字符串                                       | 布尔值                                                       |\n| repeat(n)              | 将源字符串重复n次并拼接成一个新的字符串，如果n为0，则返回空字符串 | 字符串（原字符串不改变）                                     |\n| padStart()padEnd()     | 字符串补全长度方法，头部补全/尾部补全                        | （原字符串不改变）                                           |\n| substring (start,stop) | 用于提取字符串中介于两个指定下标之间的字符。                 | 返回的子串包括 start 处的字符，但不包括 stop 处的字符.如果参数 start 与 stop 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。 |\n| 其他的一些方法         |                                                              |                                                              |\n| parseInt               | 可传入两个参数。如果只有一个参数：从0位开始到非数字位结束。如果有两个参数：parseInt(a,b)，a是以b为基数的数，转化为十进制数。parseInt(10,2)--->2parseInt(5,4)---->NaN 因为4作为进制基数，不可能存在比基数大的数（以2位例，都是1和0 ，不会有2和3） |                                                              |\n\n## 数据类型转换\n\n- 隐形类型转换\n\n- 显式类型转换\n\n  - `parseInt(str,radix)` :radix指的是被解析的数字的基数。如果省略或者为0，函数会根据str的开头字母来判断:\n\n    - 如果 string 以 \"0x\" 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。\n\n    - 如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。\n\n    - 如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。\n\n  - `parseFloat(string):` 解析一个字符串，并返回一个浮点数。判断字符串的首个字符是否是数字，如果是则对字符串解析，指导数字的末端，然后以数字返回该字符串。\n\n\n\n## 四、原生基础DOM操作\n\n| 语句                                         | 含义                                                         |                                                              |\n| -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 查找                                         | docementById                                                 |                                                              |\n| document.getElementsByClassName              | 返回一个数组                                                 |                                                              |\n| document.getElementsByTagName                |                                                              |                                                              |\n| document.getElementsByName                   | 根据元素的name属性查找                                       |                                                              |\n| document.querySelector()                     | 返回单个Node，IE8+(含），如果匹配到多个结果，只返回第一个。括号内可以是class ,id,标签，标签+class |                                                              |\n| document.querySelectorAll                    | 返回一个 NodeList                                            |                                                              |\n| 获取父级节点                                 | Node.parentNode                                              | //返回父节点                                                 |\n| Node.ownerDocument                           | //返回祖先节点                                               |                                                              |\n| 获取子节点                                   | Node.childNodes                                              | //返回相邻后代的元素节点和文本节点对象的集合(换行算作文本节点) |\n| Node.children                                | //返回相邻后代的元素节点集合                                 |                                                              |\n| Node.firstElementChild                       | //返回相邻后代第一个的元素节点                               |                                                              |\n| Node.lastElementChild                        | //返回相邻后代最后一个的元素节点                             |                                                              |\n| 获取同级元素                                 | Node.previousSibling                                         | // 返回前一个节点                                            |\n| Node.previousElementSibling                  | 返回前一个元素节点                                           |                                                              |\n| Node.nextSibling                             | // 返回后一个节点                                            |                                                              |\n|                                              | Node.nextElementSibling                                      | 返回后一个元素节点                                           |\n| 创建                                         | document.createElement                                       | 创建元素                                                     |\n| document.createTextNode                      | 创建文本节点                                                 |                                                              |\n| document.cloneNode (true)                    | 克隆一个节点，它接收一个bool参数，用来表示是否复制子元素     |                                                              |\n| document.createAttribute(\"class\")            | 创建属性节点                                                 |                                                              |\n| 复制节点                                     | var newNode=Node.cloneNode(Boolean)                          | //Boolean:true  返回Node及其全部子孙节点    //Boolean:false 只返回Node节点 |\n| 删除子节点                                   | parentNode.removeChild(childNode)                            | //已知父节点                                                 |\n| node.parentNode.removeChild(childNod)        | //未知父节点                                                 |                                                              |\n| 插入子节点                                   | parentNode.appendChild(newNode)                              | //增加节点至子节点末尾                                       |\n| parentNode .insertBefore(newNode,targetNode) | //增加节点至targetNode之前                                   |                                                              |\n| 替换节点                                     | replaceChild                                                 |                                                              |\n| 子节点相关                                   | children                                                     | 所有子节点（会有文本，注释等）                               |\n| childNodes                                   | 所有元素子节点                                               |                                                              |\n| firstChild                                   | 返回第一个子节点，不存在返回null，                           |                                                              |\n| lastChild                                    | 返回最后一个子节点，不存在返回null                           |                                                              |\n| firstElementChild                            | 返回第一个元素子节点                                         |                                                              |\n| lastElementChild                             | 返回最后一个元素子节点                                       |                                                              |\n| 兄弟节点                                     | previousSibling                                              | 节点的前一个节点，如果不存在则返回null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。 |\n| nextSibling                                  | 节点的后一个节点                                             |                                                              |\n| previousElementSibling                       | 返回前一个元素节点                                           |                                                              |\n| nextElementSibling                           | 返回后一个元素节点                                           |                                                              |\n| 元素属性                                     | setAttribute                                                 | 设置属性                                                     |\n| getAttribute                                 | 返回 属性值                                                  |                                                              |\n| 样式                                         | 直接 .style.样式                                             |                                                              |\n| 判断是否包含样式                             | classList.contains(‘zzz’)                                    |                                                              |\n| 样式的添加                                   | classList.add()                                              |                                                              |\n\n## BOM含义及使用\n\n- 含义：浏览器对象模型。\n\n  ![img](file:///C:\\Users\\ASUS\\AppData\\Local\\Temp\\ksohtml13596\\wps5.jpg)\n\n- 常用语句\n\n  | window对象语句                  | 含义                                                         |\n  | ------------------------------- | ------------------------------------------------------------ |\n  | `window.open(url,target,param)` | 打开窗口。 其中url表示要打开的地址；target表示新窗口的位置（ _blank,     _self,    _parent）;param新窗口的设置 |\n  | `window.close()`                | 关闭窗口                                                     |\n\n  **浏览器窗口尺寸获取**\n\n  |                                         |                                                              |                                      |\n  | --------------------------------------- | ------------------------------------------------------------ | ------------------------------------ |\n  | `window.innerHeight`                    | 浏览器窗口的内部高度，不包括任务栏和滚动条滚动的距离，仅仅值展现网页内容的区域范围 | 始用于Chrome、FireFox、Opera、Safari |\n  | `window.innerWidth`                     | 浏览器窗口的内部宽度                                         |                                      |\n  | `document.documentElement.clientHeight` | 适用于 IE5,6,7,8版本的语句                                   |                                      |\n  | `document.documentElement.clientWidth`  |                                                              |                                      |\n  | `document.body.clientHeight`            |                                                              |                                      |\n  | `document.body.clientWidth`             |                                                              |                                      |\n  | `screen.availWidth`                     | 可用的屏幕宽度，不会随着浏览器的拉动而变化                   |                                      |\n  | `screen.availHeight`                    |                                                              |                                      |\n\n  \n\n\n\n\n\n## 五、JS渲染\n\n- （一）、渲染的定义：整个渲染的过程其实就是将URL对应的各种资源，通过浏览器渲染引擎的解析，输出可视化的图像\n\n- （二）、渲染的步骤：1.HTML解析：将HTML文本解析成DOM树（文档对象模型）2.CSS解析：CSS对象模型3.将CSS与DOM合并，构建渲染树（renderingtree）4.布局和绘制\n\n- （三）、reflow回流和repaing重绘\n\n  - reflow：元素的样式发生改变，影响其父元素和往上追溯的祖先元素，浏览器需要重新渲染的过程。\n\n    涉及到的有：元素的显示与隐藏（树状目录的折叠展开）、占位面积（变大变小）、定位方式、文字大小、hover伪类的激活，class操作，style属性改变。\n\n  - （重绘）：不影响周围或内部布局的属性，只是改变元素的**背景色、文字**\n\n\n\n## 六、对象的几种创建方法\n\n- 1.字面量创建：\n\n  ```javascript\n  var obj = {\n      name:'范冰冰',\n      age:18,\n      hello:function(){\n          console.log(\"I am is \"+this.name)\n  }\n  ```\n\n- 2.构造函数：\n\n  - ①.系统自带的构造函数 Object()  var obj = new Object() 和1方法是一样的。\n\n  ```javascript\n  var obj  =new Object();\n  obj.name = \"张予曦\";\n  obj.age = 20;\n  ```\n\n  + 自定义构造函数：也是一样通过`new` 创建实例，为了区分其他，采用驼峰命名法\n\n    ```javascript\n    fucntion Person(name){\n        this.name = name;\n        this.health = 100;\n        this.color = 'yellow';\n        this.live = function(){\n            this.health--;\n        }\n    }\n    var per1 = new Person();\n    var per2 = new Person();\n    ```\n\n\n\n## 扩-原型链的相关知识\n\n接上节 对象的创建方法，构造函数通常都具有 属性`prototype`  和`constructor` ，而通过new 创建的实例具有属性`_proto_` ，并且`per1._proto_ == Person.prototype ` ，`Person.prototype.constructor == Person`\n\n 细节：\n\n- 控制台打印：\n\n  ![img](file:///C:\\Users\\ASUS\\AppData\\Local\\Temp\\ksohtml13596\\wps6.jpg)\n\n\n\nper1._proto_和Person.prototype 是相等的。\n\n- 同时点开 constructor，发现 constructor构造器就是指向构造函数Person的\n\n  ![img](file:///C:\\Users\\ASUS\\AppData\\Local\\Temp\\ksohtml13596\\wps7.jpg)\n\n- 与此同时，原型上也具有 __proto__,点开发现，__proto__是指向Object的。\n\n  ![img](file:///C:\\Users\\ASUS\\AppData\\Local\\Temp\\ksohtml13596\\wps8.jpg)\n\n- 这样我们就可以得出一个结论，构造函数的原型同时又是 Object的实例，又可以形成 一个原型链，效果如图所示。\n\n![img](file:///C:\\Users\\ASUS\\AppData\\Local\\Temp\\ksohtml13596\\wps9.jpg)\n\n\n\n\n\n## 扩2-继承\n\n从优到劣，三种继承方式\n\n- 原型继承\n\n  - 通过更改 `prototype` 和 `constructor` 的指向\n\n    ```javascript\n    Student.prototype = new Person();\n    Student.prototype.constructor = Student;\n    ```\n\n    Student需要继承Person。Student的prototype == Person，Student原型链上的构造器指向自己。\n\n    优缺点：1.公共属性上的值可读不可写；2.所有经由Student new出来的实例对于Person 上的属性是共享的。\n\n- 借用构造函数\n\n- 借用构造函数（通过call）\n\n  ```javascript\n  function Person(name,age){\n  \tthis.name = 'zss';\n  \tthis.age = 18;\n  }\n  function Student(name,age,score){\n  \tPerson.call(this,name,age);\n  \tthis.score = 99;\n  }\n  \n  ```\n\n  优缺点：继承过来的属性都是在自己身上的，可读可写的。同时构造器也是正确的。\n\n  ​\t\t\t\t方法没有继承，仅仅继承了属性\n\n- 组合继承方式\n\n  ```javascript\n  Student.prototype =Person.prototype;\n  Student.prototype.constructor = Student;\n  \n  function Student(name,age,score){\n  \tPerson.call(this,name,age);\n  \tthis.score = 99;\n  }\n  ```\n\n##    八、call和apply的应用区别\n\n- 语法上：\n  - apply只能传两个参数，且第二个参数为数据\n  - call可以传多个参数\n\n\n\n\n\n## 判断是否是数组\n\n- ` Array.isArray(arr)`\n- `arr instanceof Array `\n- `Object.prototype.toString.call()` 基本的数据类型都可以判断，即使是null 和undefined\n\n\n\n\n\n\n\n## 获取可视区高度\n\n```javascript\nfunction getClient() {\nreturn {\n\t\twidth: window.innerWidth || document.documentElement.clientWidth \t\t\t\t\t\t\t\t||document.body.clientWidth,\n     \theight: window.innerHeight || document.documentElement.clientHeight  \t\t\t\t\t\t\t||document.body.clientHeight\n        }\n    }\n```\n\n","tags":["笔记","vue"]}]